<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[源计划——重启博客]]></title>
    <url>%2F%E6%BA%90%E8%AE%A1%E5%88%92%E2%80%94%E2%80%94%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[博客的新家折腾了一个周末，终于把原来博客的老窝翻新了一遍。心里暗自安慰自己，以前好久不写博文就是因为原来的博客样式太丑了，恩，一定是因为这个。 博客翻新的过程就不在这里赘述了，总的来说就是google几篇hexo教程，选一个自己喜欢的themes。然后找几个做的比较好的博客，F12看一下源码，照着改一改就好了。 既然有了新家，就应该改头换面，重新。。。奋发图强！所以，我决定即日起，把平常学习、实践的一些总结，记录在博客上，一方面由于我的记性比较差，记录下来可以供自己以后温故知新，另一方面可以给有相同需求/疑问的coder们一点点参考。 希望能通过博客，结实更多的技术大拿。也希望自己可以通过博客给自己的技术多充充电！]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式Python实现]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FPython%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近找到了一篇容易理解的关于设计模式的文章，比较深刻地讲解了设计模式 史上最全设计模式导学目录（完整版）。 为了加深自己对设计模式的理解，同时熟悉Python面向对象编程的技巧，遂写下此篇文章，记录每种设计模式对应的一个练习题，并附上Python代码实现。 简单工厂模式-Simple Factory Pattern问题背景XX软件公司欲基于Python语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。XX软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。 改进前12345678910111213141516171819202122class Chart(object): def __init__(self, type): self._type = type if type.lower() == "histogram": print("初始化柱状图") elif type.lower() == "pie": print("初始化饼状图") elif type.lower() == "line": print("初始化折线图") def display(self): if self._type.lower() == "histogram": print("显示柱状图") elif self._type.lower() == "pie": print("显示化饼状图") elif self._type.lower() == "line": print("显示化折线图")if __name__ == '__main__': histogram = Chart("histogram") histogram.display() 此实现存在以下几个问题： init函数和display函数中进行了大量的if...else...判断，并且均为重复代码 Chart类既负责了所有种类图标的初始化，又负责了显示功能，违背了”单一职责原则” 如果需要新增一种图标的类型，需要修改Chart类的源码，违反了”开闭原则” 改进后12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from abc import abstractmethod, ABCMetaclass Chart(metaclass=ABCMeta): """ """ @abstractmethod def __init__(self): pass @abstractmethod def display(self): passclass HistogramChart(Chart): """ """ def __init__(self): print("初始化柱状图") def display(self): print("显示柱状图")class PieChart(Chart): """ """ def __init__(self): print("初始化饼状图") def display(self): print("显示饼状图")class LineChart(Chart): """ """ def __init__(self): print("初始化折线图") def display(self): print("显示折线图")class ChartFactory(object): @staticmethod def create(chart_type): for sc in Chart.__subclasses__(): if sc.__name__ == chart_type: return sc() return Noneif __name__ == '__main__': chart = ChartFactory.create("HistogramChart") if chart: chart.display() 此实现有以下优点： 不同种类的图标各司其职 利用Python的特性，省略了在工厂类中if...else...的判断，但是可能会增加使用复杂度，因为客户端要输入具体的类名 新增一种图表，不需要修改原有的代码 工厂方法模式-Factory Method Pattern问题背景问题描述XX软件公司欲开发一个系统运行日志记录器(Logger)，该记录器可以通过多种途径保存系统的运行日志，如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，Sunny公司的开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。如何封装记录器的初始化过程并保证多种记录器切换的灵活性是XX公司开发人员面临的一个难题。 XX公司的开发人员通过对该需求进行分析，发现该日志记录器有两个设计要点： 需要封装日志记录器的初始化过程，这些初始化工作较为复杂，例如需要初始化其他相关的类，还有可能需要读取配置文件（例如连接数据库或创建文件），导致代码较长，如果将它们都写在构造函数中，会导致构造函数庞大，不利于代码的修改和维护； 用户可能需要更换日志记录方式，在客户端代码中需要提供一种灵活的方式来选择日志记录器，尽量在不修改源代码的基础上更换或者增加日志记录方式。 改进前改进后抽象工厂模式-Abstract Factory Pattern单例模式-Singleton Pattern原型模式-Prototype Pattern建造者模式-Builder Pattern适配器模式-Adapter Pattern桥接模式-Bridge Pattern组合模式-Composite Pattern装饰模式-Decorator Pattern外观模式-Facade Pattern享元模式-Flyweight Pattern代理模式-Proxy Pattern]]></content>
      <categories>
        <category>编码技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Python 编程风格]]></title>
    <url>%2FGoogle%20Python%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Google Python Code StylePython相较于C++来说，语法和写法都比较简单，所以不像C++一样有那么多的规范，主要从语言规范和风格规范两个方面制定规范。 语言规范Lint Tip: 对你的代码运行pylint 定义 pylint是一个在Python源代码中查找bug的工具. 对于C和C++这样的不那么动态的语言, 这些bug通常由编译器来捕获. 由于Python的动态特性, 有些警告可能不对. 不过伪告警应该很少. 优点 可以捕获容易忽视的错误, 例如输入错误, 使用未赋值的变量等. 缺点 pylint不完美. 要利用其优势, 我们有时侯需要: 围绕着它来写代码 抑制其告警 改进它 忽略它. 结论 确保对你的代码运行pylint.抑制不准确的警告,以便能够将其他警告暴露出来。 你可以通过设置一个行注释来抑制告警. 例如: 1dict = 'something awful' # Bad Idea... pylint: disable=redefined-builtin pylint警告是以一个数字编号(如 C0112 )和一个符号名(如 empty-docstring )来标识的. 在编写新代码或更新已有代码时对告警进行抑制, 推荐使用符号名来标识. 如果警告的符号名不够见名知意，那么请对其增加一个详细解释。 采用这种抑制方式的好处是我们可以轻松查找抑制并回顾它们. 你可以使用命令 pylint --list-msgs 来获取pylint告警列表. 你可以使用命令 pylint --help-msg=C6409 , 以获取关于特定消息的更多信息. 相比较于之前使用的 pylint: disable-msg , 本文推荐使用 pylint: disable . 要抑制”参数未使用”告警, 你可以用””作为参数标识符, 或者在参数名前加”unused”. 遇到不能改变参数名的情况, 你可以通过在函数开头”提到”它们来消除告警. 例如: 123def foo(a, unused_b, unused_c, d=None, e=None): _ = d, e return a 导入 Tip: 仅对包和模块使用导入 定义 模块间共享代码的重用机制. 优点 命名空间管理约定十分简单. 每个标识符的源都用一种一致的方式指示. x.Obj表示Obj对象定义在模块x中. 缺点 模块名仍可能冲突. 有些模块名太长, 不太方便. 结论 不要使用from x import * 使用import x来导入包和模块. 使用from x import y, 其中x是包前缀, y是不带前缀的模块名. 使用from x import y as z, 如果两个要导入的模块都叫做y或者y太长了. 例如, 模块sound.effects.echo可以用如下方式导入: 123from sound.effects import echo...echo.EchoFilter(input, output, delay=0.7, atten=4) 导入时不要使用相对名称. 即使模块在同一个包中, 也要使用完整包名. 这能帮助你避免无意间导入一个包两次. 包 Tip: 使用模块的全路径名来导入每个模块 优点 避免模块名冲突. 查找包更容易. 缺点 部署代码变难, 因为你必须复制包层次. 结论 所有的新代码都应该用完整包名来导入每个模块. 应该像下面这样导入: 12345# Reference in code with complete name.import sound.effects.echo# Reference in code with just module name (preferred).from sound.effects import echo 异常 Tip: 允许使用异常, 但必须小心 定义 异常是一种跳出代码块的正常控制流来处理错误或者其它异常条件的方式. 优点 正常操作代码的控制流不会和错误处理代码混在一起. 当某种条件发生时, 它也允许控制流跳过多个框架. 例如, 一步跳出N个嵌套的函数, 而不必继续执行错误的代码. 缺点 可能会导致让人困惑的控制流. 调用库时容易错过错误情况. 结论 异常必须遵守特定条件: 像这样触发异常:raise MyException(&quot;Error message&quot;)或者raise MyException. 不要使用两个参数的形式(raise MyException, &quot;Error message&quot;)或者过时的字符串异常(raise &quot;Error message&quot;). 模块或包应该定义自己的特定域的异常基类, 这个基类应该从内建的Exception类继承. 模块的异常基类应该叫做”Error”. 12class Error(Exception): pass 永远不要使用except:语句来捕获所有异常, 也不要捕获Exception或者StandardError, 除非你打算重新触发该异常, 或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面, Python非常宽容,except:真的会捕获包括Python语法错误在内的任何错误. 使用except:很容易隐藏真正的bug. 尽量减少try/except块中的代码量. try块的体积越大, 期望之外的异常就越容易被触发. 这种情况下, try/except块将隐藏真正的错误. 使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码. 这对于清理资源常常很有用, 例如关闭文件. 当捕获异常时, 使用 as 而不要用逗号. 例如 1234try: raise Errorexcept Error as error: pass 全局变量 Tip: 避免全局变量 定义 定义在模块级的变量. 优点 偶尔有用. 缺点 导入时可能改变模块行为, 因为导入模块时会对模块级变量赋值. 结论 避免使用全局变量, 用类变量来代替. 但也有一些例外: 脚本的默认选项. 模块级常量. 例如:PI = 3.14159. 常量应该全大写, 用下划线连接. 有时候用全局变量来缓存值或者作为函数返回值很有用. 如果需要, 全局变量应该仅在模块内部可用, 并通过模块级的公共函数来访问. 嵌套/局部/内部类或函数 Tip: 鼓励使用嵌套/本地/内部类或函数 定义 类可以定义在方法, 函数或者类中. 函数可以定义在方法或函数中. 封闭区间中定义的变量对嵌套函数是只读的. 优点 允许定义仅用于有效范围的工具类和函数. 缺点 嵌套类或局部类的实例不能序列化(pickled). 结论 推荐使用. 列表推导(List Comprehensions) Tip: 可以在简单情况下使用 定义 列表推导(list comprehensions)与生成器表达式(generator expression)提供了一种简洁高效的方式来创建列表和迭代器, 而不必借助map(), filter(), 或者lambda. 优点 简单的列表推导可以比其它的列表创建方法更加清晰简单. 生成器表达式可以十分高效, 因为它们避免了创建整个列表. 缺点 复杂的列表推导或者生成器表达式可能难以阅读. 结论 适用于简单情况. 每个部分应该单独置于一行: 映射表达式, for语句, 过滤器表达式. 禁止多重for语句或过滤器表达式. 复杂情况下还是使用循环. 12345678910111213141516171819202122Yes:result = []for x in range(10): for y in range(5): if x * y &gt; 10: result.append((x, y))for x in xrange(5): for y in xrange(5): if x != y: for z in xrange(5): if y != z: yield (x, y, z)return ((x, complicated_transform(x)) for x in long_generator_function(parameter) if x is not None)squares = [x * x for x in range(10)]eat(jelly_bean for jelly_bean in jelly_beans if jelly_bean.color == 'black') 123456789No:result = [(x, y) for x in range(10) for y in range(5) if x * y &gt; 10]return ((x, y, z) for x in xrange(5) for y in xrange(5) if x != y for z in xrange(5) if y != z) 默认迭代器和操作符 Tip: 如果类型支持, 就使用默认迭代器和操作符. 比如列表, 字典及文件等. 定义 容器类型, 像字典和列表, 定义了默认的迭代器和关系测试操作符(in和not in) 优点 默认操作符和迭代器简单高效, 它们直接表达了操作, 没有额外的方法调用. 使用默认操作符的函数是通用的. 它可以用于支持该操作的任何类型. 缺点 你没法通过阅读方法名来区分对象的类型(例如, has_key()意味着字典). 不过这也是优点. 结论 如果类型支持, 就使用默认迭代器和操作符, 例如列表, 字典和文件. 内建类型也定义了迭代器方法. 优先考虑这些方法, 而不是那些返回列表的方法. 当然，这样遍历容器时，你将不能修改容器. 12345Yes: for key in adict: ... if key not in adict: ... if obj in alist: ... for line in afile: ... for k, v in dict.iteritems(): ... 123No: for key in adict.keys(): ... if not adict.has_key(key): ... for line in afile.readlines(): ... 生成器 Tip: 按需使用生成器. 定义 所谓生成器函数, 就是每当它执行一次生成(yield)语句, 它就返回一个迭代器, 这个迭代器生成一个值. 生成值后, 生成器函数的运行状态将被挂起, 直到下一次生成. 优点 简化代码, 因为每次调用时, 局部变量和控制流的状态都会被保存. 比起一次创建一系列值的函数, 生成器使用的内存更少. 缺点 无 结论 鼓励使用. 注意在生成器函数的文档字符串中使用Yields:而不是Returns:. Lambda函数 Tip: 适用于单行函数 定义 与语句相反, lambda在一个表达式中定义匿名函数. 常用于为map()和filter()之类的高阶函数定义回调函数或者操作符. 优点 方便 缺点 比本地函数更难阅读和调试. 没有函数名意味着堆栈跟踪更难理解. 由于lambda函数通常只包含一个表达式, 因此其表达能力有限. 结论 适用于单行函数. 如果代码超过60-80个字符, 最好还是定义成常规(嵌套)函数. 对于常见的操作符，例如乘法操作符，使用operator模块中的函数以代替lambda函数. 例如, 推荐使用 operator.mul, 而不是lambda x, y: x * y. 条件表达式 Tip: 适用于单行函数 定义 条件表达式是对于if语句的一种更为简短的句法规则. 例如:x = 1 if cond else 2. 优点 比if语句更加简短和方便. 缺点 比if语句更加简短和方便. 结论 适用于单行函数. 在其他情况下，推荐使用完整的if语句. 默认参数值 Tip: 适用于大部分情况. 定义 你可以在函数参数列表的最后指定变量的值, 例如, def foo(a, b = 0):. 如果调用foo时只带一个参数, 则b被设为0. 如果带两个参数, 则b的值等于第二个参数. 优点 你经常会碰到一些使用大量默认值的函数, 但偶尔(比较少见)你想要覆盖这些默认值. 默认参数值提供了一种简单的方法来完成这件事, 你不需要为这些罕见的例外定义大量函数. 同时, Python也不支持重载方法和函数, 默认参数是一种”仿造”重载行为的简单方式. 缺点 默认参数只在模块加载时求值一次. 如果参数是列表或字典之类的可变类型, 这可能会导致问题. 如果函数修改了对象(例如向列表追加项), 默认值就被修改了. 结论 鼓励使用, 不过有如下注意事项: 不要在函数或方法定义中使用可变对象作为默认值. 123Yes: def foo(a, b=None): if b is None: b = [] 123456No: def foo(a, b=[]): ...No: def foo(a, b=time.time()): # The time the module was loaded??? ...No: def foo(a, b=FLAGS.my_thing): # sys.argv has not yet been parsed... ... 属性(properties) Tip: 访问和设置数据成员时, 你通常会使用简单, 轻量级的访问和设置函数. 建议用属性（properties）来代替它们. 定义 一种用于包装方法调用的方式. 当运算量不大, 它是获取和设置属性(attribute)的标准方式. 优点 通过消除简单的属性(attribute)访问时显式的get和set方法调用, 可读性提高了. 允许懒惰的计算. 用Pythonic的方式来维护类的接口. 就性能而言, 当直接访问变量是合理的, 添加访问方法就显得琐碎而无意义. 使用属性(properties)可以绕过这个问题. 将来也可以在不破坏接口的情况下将访问方法加上. 缺点 属性(properties)是在get和set方法声明后指定, 这需要使用者在接下来的代码中注意: set和get是用于属性(properties)的(除了用@property装饰器创建的只读属性). 必须继承自object类. 可能隐藏比如操作符重载之类的副作用. 继承时可能会让人困惑. 结论 你通常习惯于使用访问或设置方法来访问或设置数据, 它们简单而轻量. 不过我们建议你在新的代码中使用属性. 只读属性应该用@property装饰器 来创建. 12345678910111213class Student(object):@propertydef score(self): return self._score@score.setterdef score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value True/False的求值 Tip: 尽可能使用隐式false 定义 Python在布尔上下文中会将某些值求值为false. 按简单的直觉来讲, 就是所有的”空”值都被认为是false. 因此0，None,[],{},&quot;&quot;都被认为是false. 优点 使用Python布尔值的条件语句更易读也更不易犯错. 大部分情况下, 也更快. 缺点 对C/C++开发人员来说, 可能看起来有点怪. 结论 尽可能使用隐式的false, 例如: 使用if foo:而不是 if foo != []:. 不过还是有一些注意事项需要你铭记在心: 永远不要用==或者!=来比较单件, 比如None. 使用is或者is not. 注意: 当你写下if x:时, 你其实表示的是if x is not None. 例如: 当你要测试一个默认值是None的变量或参数是否被设为其它值. 这个值在布尔语义下可能是false! 永远不要用==将一个布尔量与false相比较. 使用if not x:代替. 如果你需要区分false和None, 你应该用像if not x and x is not None:这样的语句. 对于序列(字符串, 列表, 元组), 要注意空序列是false. 因此if not seq:或者if seq:比if len(seq):或if not len(seq):要更好. 处理整数时, 使用隐式false可能会得不偿失(即不小心将None当做0来处理). 你可以将一个已知是整型(且不是len()的返回结果)的值与0比较. 12345678Yes: if not users: print 'no users' if foo == 0: self.handle_zero() if i % 10 == 0: self.handle_multiple_of_ten() 12345678No: if len(users) == 0: print 'no users' if foo is not None and not foo: self.handle_zero() if not i % 10: self.handle_multiple_of_ten() 注意’0’(字符串)会被当做true. 过时的语言特性 Tip: 尽可能使用字符串方法取代字符串模块. 使用函数调用语法取代apply(). 使用列表推导, for循环取代filter(), map()以及reduce(). 定义 当前版本的Python提供了大家通常更喜欢的替代品. 结论 我们不使用不支持这些特性的Python版本, 所以没理由不用新的方式. 1234567Yes: words = foo.split(':') [x[1] for x in my_list if x[2] == 5] map(math.sqrt, data) # Ok. No inlined lambda expression. fn(*args, **kwargs) 12345No: words = string.split(foo, ':') map(lambda x: x[1], filter(lambda x: x[2] == 5, my_list)) apply(fn, args, kwargs) 词法作用域(Lexical Scoping) Tip: 推荐使用 定义 嵌套的Python函数可以引用外层函数中定义的变量, 但是不能够对它们赋值. 变量绑定的解析是使用词法作用域, 也就是基于静态的程序文本. 对一个块中的某个名称的任何赋值都会导致Python将对该名称的全部引用当做局部变量, 甚至是赋值前的处理. 如果碰到global声明, 该名称就会被视作全局变量. 一个使用这个特性的例子: 123456def get_adder(): """Returns a function that adds numbers to a given number.""" def adder(summand1, summand2): return summand1 + summand2 return adder 优点 通常可以带来更加清晰, 优雅的代码. 尤其会让有经验的Lisp和Scheme(还有Haskell, ML等)程序员感到欣慰. 缺点 可能导致让人迷惑的bug. 例如下面这个依据 PEP-0227 的例子: 12345678910i = 4def foo(x): def bar(): print i, # ... # A bunch of code here # ... for i in x: # Ah, i *is* local to Foo, so this is what Bar sees print i, bar() 因此foo([1, 2, 3])会打印1 2 3 3, 不是1 2 3 4. x是一个列表, for循环其实是将x中的值依次赋给i.这样对i的赋值就隐式的发生了, 整个foo函数体中的i都会被当做局部变量, 包括bar()中的那个. 结论 鼓励使用 函数与方法装饰器 Tip: 如果好处很显然, 就明智而谨慎的使用装饰器 定义 用于函数及方法的装饰器 (也就是@标记). 最常见的装饰器是@classmethod和@staticmethod, 用于将常规函数转换成类方法或静态方法. 不过, 装饰器语法也允许用户自定义装饰器. 特别地, 对于某个函数my_decorator, 下面的两段代码是等效的: 1234class C(object): @my_decorator def method(self): # method body ... 1234class C(object): def method(self): # method body ... method = my_decorator(method) 优点 优雅的在函数上指定一些转换. 该转换可能减少一些重复代码, 保持已有函数不变(enforce invariants), 等. 缺点 装饰器可以在函数的参数或返回值上执行任何操作, 这可能导致让人惊异的隐藏行为. 而且, 装饰器在导入时执行. 从装饰器代码的失败中恢复更加不可能. 结论 如果好处很显然, 就明智而谨慎的使用装饰器. 装饰器应该遵守和函数一样的导入和命名规则. 装饰器的python文档应该清晰的说明该函数是一个装饰器. 请为装饰器编写单元测试. 避免装饰器自身对外界的依赖(即不要依赖于文件, socket, 数据库连接等), 因为装饰器运行时这些资源可能不可用(由 pydoc 或其它工具导入). 应该保证一个用有效参数调用的装饰器在所有情况下都是成功的. 线程 Tip: 不要依赖内建类型的原子性. 虽然Python的内建类型例如字典看上去拥有原子操作, 但是在某些情形下它们仍然不是原子的(即: 如果hash或eq被实现为Python方法)且它们的原子性是靠不住的. 你也不能指望原子变量赋值(因为这个反过来依赖字典). 优先使用Queue模块的Queue数据类型作为线程间的数据通信方式. 另外, 使用threading模块及其锁原语(locking primitives). 了解条件变量的合适使用方式, 这样你就可以使用threading.Condition来取代低级别的锁了. 威力过大的特性 Tip: 避免使用这些特性 定义 Python是一种异常灵活的语言, 它为你提供了很多花哨的特性, 诸如元类(metaclasses), 字节码访问, 任意编译(on-the-fly compilation), 动态继承, 对象父类重定义(object reparenting), 导入黑客(import hacks), 反射, 系统内修改(modification of system internals), 等等. 优点 强大的语言特性, 能让你的代码更紧凑. 缺点 使用这些很”酷”的特性十分诱人, 但不是绝对必要. 使用奇技淫巧的代码将更加难以阅读和调试. 开始可能还好(对原作者而言), 但当你回顾代码, 它们可能会比那些稍长一点但是很直接的代码更加难以理解. 结论 在你的代码中避免这些特性. 风格规范分号 Tip: 不要在行尾加分号, 也不要用分号将两条命令放在同一行. 行长度 Tip: 每行不超过80个字符 例外: 1. 长的导入模块语句 1. 注释里的URL 不要使用反斜杠连接行. Python会将圆括号,中括号和花括号中的行隐式的连接起来 , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号. 12345Yes: foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接: 12x = ('This will build a very long long ' 'long long long long long long string') 在注释中，如果必要，将长的URL放在一行上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 Google 开源项目风格指南latestSearch docsGoogle 开源项目风格指南 (中文版)C++ 风格指南 - 内容目录Objective-C 风格指南 - 内容目录Python 风格指南 - 内容目录扉页背景Python语言规范Python风格规范分号行长度括号缩进空行空格Shebang注释类字符串文件和socketsTODO注释导入格式语句访问控制命名Main临别赠言Shell 风格指南 - 内容目录Love Documentation? Write the Docs is a community full of people like you!Sponsored · Ads served ethicallyGoogle 开源项目风格指南Docs » Python 风格指南 - 内容目录 » Python风格规范 Edit on GitHubPython风格规范分号Tip不要在行尾加分号, 也不要用分号将两条命令放在同一行.行长度Tip每行不超过80个字符例外:长的导入模块语句注释里的URL不要使用反斜杠连接行.Python会将 圆括号, 中括号和花括号中的行隐式的连接起来 , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.```PythonYes: foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0) if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'): 如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接: 12x = ('This will build a very long long ' 'long long long long long long string') 在注释中，如果必要，将长的URL放在一行上。 12Yes: # See details at # http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html 123No: # See details at # http://www.example.com/us/developer/documentation/api/content/\ # v2.0/csv_file_name_extension_full_specification.html 括号 Tip: 宁缺毋滥的使用括号 除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的. 12345678910Yes: if foo: bar() while x: x = bar() if x and y: bar() if not x: bar() return foo for (x, y) in dict.items(): ... 12345No: if (x): bar() if not(x): bar() return (foo) 缩进 Tip: 用4个空格来缩进代码 绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素, 或者使用4空格的悬挂式缩进(这时第一行不应该有参数): 12345678910111213141516171819202122Yes: # Aligned with opening delimiter foo = long_function_name(var_one, var_two, var_three, var_four) # Aligned with opening delimiter in a dictionary foo = &#123; long_dictionary_key: value1 + value2, ... &#125; # 4-space hanging indent; nothing on first line foo = long_function_name( var_one, var_two, var_three, var_four) # 4-space hanging indent in a dictionary foo = &#123; long_dictionary_key: long_dictionary_value, ... &#125; 123456789101112131415No: # Stuff on first line forbidden foo = long_function_name(var_one, var_two, var_three, var_four) # 2-space hanging indent forbidden foo = long_function_name( var_one, var_two, var_three, var_four) # No hanging indent in a dictionary foo = &#123; long_dictionary_key: long_dictionary_value, ... &#125; 空行 顶级定义之间空两行, 方法定义之间空一行 顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行. 空格 按照标准的排版规范来使用标点两边的空格 括号内不要有空格. 12Yes: spam(ham[1], &#123;eggs: 2&#125;, [])No: spam( ham[ 1 ], &#123; eggs: 2 &#125;, [ ] ) 不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾). 123456Yes: if x == 4: print x, y x, y = y, xNo: if x == 4 : print x , y x , y = y , x 参数列表, 索引或切片的左括号前不应加空格. 12345Yes: spam(1)no: spam (1)Yes: dict['key'] = list[index]No: dict ['key'] = list [index] 在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not). 至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致. 12Yes: x == 1No: x&lt;1 当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格. 12Yes: def complex(real, imag=0.0): return magic(r=real, i=imag)No: def complex(real, imag = 0.0): return magic(r = real, i = imag) 不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等): 12345678Yes: foo = 1000 # comment long_name = 2 # comment that should not be aligned dictionary = &#123; "foo": 1, "long_name": 2, &#125; 12345678No: foo = 1000 # comment long_name = 2 # comment that should not be aligned dictionary = &#123; "foo" : 1, "long_name": 2, &#125; Shebang 大部分.py文件不必以#!作为文件的开始. 根据 PEP-394 , 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始. 在计算机科学中, Shebang (也称为Hashbang)是一个由井号和叹号构成的字符串行(#!), 其出现在文本文件的第一行的前两个字符. 在文件中存在Shebang的情况下, 类Unix操作系统的程序载入器会分析Shebang后的内容, 将这些内容作为解释器指令, 并调用该指令, 并将载有Shebang的文件路径作为该解释器的参数. 例如, 以指令#!/bin/sh开头的文件在执行时会实际调用/bin/sh程序. #!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入#!. 注释 确保对模块, 函数, 方法和行内注释使用正确的风格 文档字符串Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句. 这些字符串可以通过对象的__doc__成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样). 我们对文档字符串的惯例是使用三重双引号&quot;&quot;&quot;. 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范. 模块每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板. 函数和方法下文所指的函数,包括函数, 方法, 以及生成器. 一个函数必须要有文档字符串, 除非它满足以下条件: 外部不可见 非常短小 简单明了 文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述”怎么做”, 除非是一些复杂的算法. 文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码, 在代码旁边加注释会比使用文档字符串更有意义. Args: 列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar. Returns: (或者 Yields: 用于生成器) 描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略. Raises: 列出与接口有关的所有异常. 123456789101112131415161718192021222324252627282930def fetch_bigtable_rows(big_table, keys, other_silly_variable=None): """Fetches rows from a Bigtable. Retrieves rows pertaining to the given keys from the Table instance represented by big_table. Silly things may happen if other_silly_variable is not None. Args: big_table: An open Bigtable Table instance. keys: A sequence of strings representing the key of each table row to fetch. other_silly_variable: Another optional variable, that has a much longer name than the other args, and which does nothing. Returns: A dict mapping keys to the corresponding table row data fetched. Each row is represented as a tuple of strings. For example: &#123;'Serak': ('Rigel VII', 'Preparer'), 'Zim': ('Irk', 'Invader'), 'Lrrr': ('Omicron Persei 8', 'Emperor')&#125; If a key from the keys argument is missing from the dictionary, then that row was not found in the table. Raises: IOError: An error occurred accessing the bigtable.Table object. """ pass 类类应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式. 123456789101112131415161718class SampleClass(object): """Summary of class here. Longer class information.... Longer class information.... Attributes: likes_spam: A boolean indicating if we like SPAM or not. eggs: An integer count of the eggs we have laid. """ def __init__(self, likes_spam=False): """Inits SampleClass with blah.""" self.likes_spam = likes_spam self.eggs = 0 def public_method(self): """Performs operation blah.""" 块注释和行注释最需要写注释的是代码中那些技巧性的部分. 如果你在下次代码审查的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释. 123456# We use a weighted dictionary search to find out where i is in# the array. We extrapolate position based on the largest num# in the array and the array size and then do binary search to# get the exact number.if i &amp; (i-1) == 0: # true iff i is a power of 2 为了提高可读性, 注释应该至少离开代码2个空格. 另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么. 12# BAD COMMENT: Now go through the b array and make sure whenever i occurs# the next element is i+1 类 Tip: 如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样. 123456789101112Yes: class SampleClass(object): pass class OuterClass(object): class InnerClass(object): pass class ChildClass(ParentClass): """Explicitly inherits from another class already.""" 12345678No: class SampleClass: pass class OuterClass: class InnerClass: pass 继承自object是为了使属性(properties)正常工作, 并且这样可以保护你的代码, 使其不受PEP-3000 的一个特殊的潜在不兼容性影响. 这样做也定义了一些特殊的方法, 这些方法实现了对象的默认语义, 包括__new__, __init__, __delattr__, __getattribute__, __setattr__, __hash__, __repr__, and __str__ . 字符串 Tip: 即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在+和%之间好好判定. 12345Yes: x = a + b x = '%s, %s!' % (imperative, expletive) x = '&#123;&#125;, &#123;&#125;!'.format(imperative, expletive) x = 'name: %s; score: %d' % (name, n) x = 'name: &#123;&#125;; score: &#123;&#125;'.format(name, n) 1234No: x = '%s%s' % (a, b) # use + in this case x = '&#123;&#125;&#123;&#125;'.format(a, b) # use + in this case x = imperative + ', ' + expletive + '!' x = 'name: ' + name + '; score: ' + str(n) 避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用.join连接列表. (也可以将每个子串写入一个cStringIO.StringIO缓存中.) 1234No: employee_table = '&lt;table&gt;' for last_name, first_name in employee_list: employee_table += '&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;' % (last_name, first_name) employee_table += '&lt;/table&gt;' 在同一个文件中, 保持使用字符串引号的一致性. 使用单引号’或者双引号”之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. PyLint已经加入了这一检查. 为多行字符串使用三重双引号”“”而非三重单引号’‘’. 当且仅当项目中使用单引号’来引用字符串时, 才可能会使用三重’‘’为非文档字符串的多行字符串来标识引用. 文档字符串必须使用三重双引号”“”. 不过要注意, 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致. 1234567Yes: print ("This is much nicer.\n" "Do it this way.\n")No: print """This is pretty ugly. Don't do this. """ 文件和sockets Tip: 在文件和sockets结束时, 显式的关闭它. 除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如: 它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽. 持有文件将会阻止对于文件的其他诸如移动、删除之类的操作. 仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会抛出异常, 并使得问题快速显现出来. 而且, 幻想当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因: 没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长. 对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等). 推荐使用&quot;with&quot;语句 以管理文件: 123with open("hello.txt") as hello_file: for line in hello_file: print line 对于不支持使用&quot;with&quot;语句的类似文件的对象,使用 contextlib.closing(): 12345import contextlibwith contextlib.closing(urllib.urlopen("http://www.python.org/")) as front_page: for line in front_page: print line TODO注释 Tip: 为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了. TODO注释应该在所有开头处包含&quot;TODO&quot;字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号. 接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节). 写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字. 12# TODO(kl@gmail.com): Use a "*" here for string repetition.# TODO(Zeke) Change this to use relations. 如果你的TODO是”将来做某事”的形式, 那么请确保你包含了一个指定的日期(“2009年11月解决”)或者一个特定的事件(“等到所有的客户都可以处理XML请求就移除这些代码”). 导入格式 每个导入应该独占一行 123Yes: import os import sysNo: import os, sys 导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组: 标准库导入 第三方库导入 应用程序指定导入 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写. 12345import foofrom foo import barfrom foo.bar import bazfrom foo.bar import Quuxfrom Foob import ar 访问控制 在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性. 另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 get_foo() 和 set_foo() 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化. 命名 Tip: module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name. 应该避免的名称 单字符名称, 除了计数器和迭代器. 包/模块名中的连字符(-) 双下划线开头并结尾的名称(Python保留, 例如init) 命名约定 所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的. 用单下划线(_)开头表示模块变量或函数是protected的(使用from x import x时不会包含). 用双下划线(__)开头的实例变量或方法表示类内私有. 将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块. 对类名使用大写字母开头的单词(如CapWords, 即Pascal风格), 但是模块名应该用小写加下划线的方式(如lower_with_under.py). 尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰. Python之父Guido推荐的规范 Type Public Internal Modules lower_with_under _lower_with_under Packages lower_with_under Classes CapWords _CapWords Exceptions CapWords Functions lower_with_under() _lower_with_under() Global/Class Constants CAPS_WITH_UNDER _CAPS_WITH_UNDER Global/Class Variables lower_with_under _lower_with_under Instance Variables lower_with_under _lower_with_under (protected) or __lower_with_under (private) Method Names lower_with_under() _lower_with_under() (protected) or __lower_with_under() (private) Function/Method Parameters lower_with_under Local Variables lower_with_under Main Tip: 即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中. 在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查if __name__ == &#39;__main__&#39;, 这样当模块被导入时主程序就不会被执行. 12345def main(): ...if __name__ == '__main__': main() 所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作. 总结请务必保持代码的一致性。 如果你正在编辑代码, 花几分钟看一下周边代码, 然后决定风格. 如果它们在所有的算术操作符两边都使用空格, 那么你也应该这样做. 如果它们的注释都用标记包围起来, 那么你的注释也要这样. 制定风格指南的目的在于让代码有规可循, 这样人们就可以专注于”你在说什么”, 而不是”你在怎么说”. 我们在这里给出的是全局的规范, 但是本地的规范同样重要. 如果你加到一个文件里的代码和原有代码大相径庭, 它会让读者不知所措. 避免这种情况.]]></content>
      <categories>
        <category>编码技能</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google C++ 编程风格]]></title>
    <url>%2FGoogle%20C%2B%2B%20Code%20Style%2F</url>
    <content type="text"><![CDATA[Google C++ Code StyleC++ 是 Google 大部分开源项目的主要编程语言。正如每个 C++ 程序员都知道的， C++ 有很多强大的特性， 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug， 难以阅读和维护。 本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性。这些规则在保证代码易于管理的同时， 也能高效使用 C++ 的语言特性。 风格， 亦被称作可读性， 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当， 因为这些习惯远不止源代码文件格式化这么简单。 使代码易于管理的方法之一是加强代码一致性。让任何程序员都可以快速读懂你的代码这点非常重要。保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义。创建通用， 必需的习惯用语和模式可以使代码更容易理解。在一些情况下可能有充分的理由改变某些编程风格， 但我们还是应该遵循一致性原则，尽量不这么做。 头文件一个.cc/.cpp文件都应该对应一个.h文件。也有些常见例外，例如单元测试代码和只包含main()入口函数的源文件。 Self-contained 头文件 Tip: 头文件应该能够自给自足（self-contained，也就是可以作为第一个头文件被引入），简单来说就是头文件中依赖的其他声明要在头文件中定义清楚，而不能依赖在.cc文件中调整引入顺序解决依赖。 如果.h文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的.cc文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。 有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。 #define保护 Tip: 所有头文件都应该使用 #define 来防止头文件被多重包含， 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_。 为保证唯一性， 头文件的命名应该基于所在项目源代码树的全路径. 例如， 项目 foo中的头文件foo/src/bar/baz.h可按如下方式保护: 1234#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ #define 与 #pragma once区别 #pragma once是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差。 所以尽量使用#ifndef来避免头文件重复引用。 前置声明 Tip: 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。 优点 前置声明能够节省编译时间，多余的#include会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。#include使代码因为头文件中无关的改动而被重新编译多次。 缺点 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。例如扩大形参类型，加个自带默认参数的模板形参等等。 前置声明来自命名空间 std::的symbol时，其行为未定义。 很难判断什么时候该用前置声明，什么时候该用#include。极端情况下，用前置声明代替includes甚至都会暗暗地改变代码的含义： 123456789// b.h:struct B &#123;&#125;;struct D : B &#123;&#125;// good_user.cc:#include "b.h"void f(B*);void f(void*);void test(D* x) &#123; f(x); &#125; // calls f(B*) 如果#include被 B 和 D 的前置声明替代，test()就会调用f(void*)。 前置声明了不少来自头文件的symbol时，就会比单单一行的include冗长。 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。 结论 尽量避免前置声明那些定义在其他项目中的实体。 函数：总是使用#include。 类模板：优先使用#include。 内联函数 Tip: 只有当函数只有10行甚至更少时才将其定义为内联函数。 定义 当函数被声明为内联函数之后， 编译器会将其内联展开， 而不是按通常的函数调用机制进行调用。 优点 只要内联的函数体较小， 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短， 性能关键的函数， 鼓励使用内联。 缺点 滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减， 这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小， 但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存， 小巧的代码往往执行更快。 结论 一个较为合理的经验准则是， 不要内联超过10行的函数。谨慎对待析构函数， 析构函数往往比其表面看起来要更长， 因为有隐含的成员和基类析构函数被调用! 有些函数即使声明为内联的也不一定会被编译器内联， 这点很重要; 比如虚函数和递归函数就不会被正常内联。通常， 递归函数不应该声明成内联函数，递归调用堆栈的展开并不像循环那么简单， 比如递归层数在编译时可能是未知的， 大多数编译器都不支持内联递归函数。虚函数内联的主要原因则是想把它的函数体放在类定义内， 为了图个方便， 抑或是当作文档描述其行为， 比如精短的存取函数. #include的路径及顺序 Tip: 使用标准的头文件包含顺序可增强可读性， 避免隐藏依赖: 相关头文件， C 库， C++ 库， 其他库的 .h， 本项目内的 .h。 项目内头文件应按照项目源代码目录树结构排列， 避免使用 UNIX 特殊的快捷目录.(当前目录)或..(上级目录). 例如， google-awesome-project/src/base/logging.h应该按如下方式包含: #include &quot;base/logging.h&quot; 又如，dir/foo.cc或dir/foo_test.cc的主要作用是实现或测试dir2/foo2.h的功能，foo.cc中包含头文件的次序如下： dir2/foo2.h（优先位置，详情如下） C 系统文件 C++ 系统文件 其他库的.h文件 本项目内.h文件 这种优先的顺序排序保证当dir2/foo2.h遗漏某些必要的库时，dir/foo.cc或dir/foo_test.cc的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。 您所依赖的符号(symbols)被哪些头文件所定义，您就应该包含(include)哪些头文件，前置声明(forward declarations)情况除外。比如您要用到bar.h中的某个符号， 哪怕您所包含的 foo.h已经包含了bar.h， 也照样得包含bar.h， 除非 foo.h有明确说明它会自动向您提供bar.h中的symbol。 不过，凡是cc文件所对应的「相关头文件」已经包含的，就不用再重复包含进其cc文件里面了，就像foo.cc只包含foo.h就够了，不用再管后者所包含的其它内容。 举例来说，google-awesome-project/src/foo/internal/fooserver.cc的包含次序如下: 1234567891011#include "foo/public/fooserver.h" // 优先位置#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;hash_map&gt;#include &lt;vector&gt;#include "base/basictypes.h"#include "base/commandlineflags.h"#include "foo/public/bar.h" 小结 避免多重包含 头文件尽量避免使用前置声明，直接include 内联函数最好少于10行。类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的.cc文件里 包含文件的次序除了美观之外， 最重要的是可以减少隐藏依赖，使每个头文件在“最需要编译”的地方编译。 作用域命名空间 Tip: 鼓励在.cc文件内使用匿名命名空间或static声明. 使用具名的命名空间时，其名称可基于项目名或相对路径。禁止使用using指示(using-directive e.g. using namespace foo;)。禁止使用内联命名空间(inline namespace)。 定义 命名空间将全局作用域细分为独立的， 具名的作用域， 可有效防止全局作用域的命名冲突。 优点 类已经提将命名分割在不同类的作用域内， 命名空间在这基础上又封装了一层。 举例来说， 两个不同项目的全局作用域都有一个类Foo， 这样在编译或运行时造成冲突。如果每个项目将代码置于不同命名空间中，project1::Foo和project2::Foo作为不同符号自然不会冲突。 内联命名空间会自动把内部的标识符放到外层作用域，比如： 12345namespace X &#123;inline namespace Y &#123;void foo();&#125; // namespace Y&#125; // namespace X X::Y::foo()与X::foo()彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。 缺点 命名空间具有迷惑性， 因为它们使得区分两个相同命名所指代的定义更加困难。 内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。 结论 根据下文将要提到的策略合理使用命名空间。 遵守命名空间命名中的规则。 像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。 用命名空间把文件包含， 以及类的前置声明以外的整个源文件封装起来， 以区别于其它命名空间: 123456789101112// .h 文件namespace mynamespace &#123;// 所有声明都置于命名空间中// 注意不要使用缩进class MyClass &#123; public: ... void Foo();&#125;;&#125; // namespace mynamespace 123456789// .cc 文件namespace mynamespace &#123;// 函数定义都置于命名空间中void MyClass::Foo() &#123; ...&#125;&#125; // namespace mynamespace 不要在命名空间std内声明任何东西， 包括标准库的类前置声明。在std命名空间声明实体是未定义的行为， 会导致如不可移植。声明标准库下的实体， 需要包含对应的头文件。 不应该使用using指示 引入整个命名空间的标识符号。 12// 禁止 —— 污染命名空间using namespace foo; 不要在头文件中使用命名空间别名除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。 禁止用内联命名空间 匿名命名空间和静态变量 Tip: 在.cc文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为static。但是不要在.h文件中这么做。 定义 所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为static拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。 结论 推荐、鼓励在.cc中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在.h中使用。 匿名命名空间的声明和具名的格式相同，在最后注释上namespace: 123namespace &#123;...&#125; // namespace 非成员函数、静态成员函数和全局函数 Tip: 使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。 优点 某些情况下，非成员函数和静态成员函数是非常有用的，将非成员函数放在命名空间内可避免污染全局作用域。 缺点 将非成员函数和静态成员函数作为新类的成员或许更有意义，当它们需要访问外部资源或具有重要的依赖关系时更是如此。 结论 有时，把函数的定义同类的实例脱钩是有益的，甚至是必要的。这样的函数可以被定义成静态成员，或是非成员函数。非成员函数不应依赖于外部变量，应尽量置于某个命名空间内。相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用2.1命名空间。举例而言，对于头文件myproject/foo_bar.h，应当使用 123456namespace myproject &#123;namespace foo_bar &#123;void Function1();void Function2();&#125; // namespace foo_bar&#125; // namespace myproject 而非 1234567namespace myproject &#123;class FooBar &#123;public:static void Function1();static void Function2();&#125;;&#125; // namespace myproject 定义在同一编译单元的函数，被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖；静态成员函数对此尤其敏感。可以考虑提取到新类中，或者将函数置于独立库的命名空间内。 如果你必须定义非成员函数，又只是在.cc文件中使用它，可使用匿名命名空间或static链接关键字(如static int Foo() {...}) 限定其作用域。 局部变量 Tip: 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。 C++允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值, 比如: 12int i;i = f(); // 坏——初始化和声明分离 1int j = g(); // 好——初始化时声明 123vector&lt;int&gt; v;v.push_back(1); // 用花括号初始化更好v.push_back(2); 1vector&lt;int&gt; v = &#123;1, 2&#125;; // 好——v 一开始就初始化 属于if,while和for语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言: 1while (const char* p = strchr(str, '/')) str = p + 1; 有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数。这会导致效率降低。 12345// 低效的实现for (int i = 0; i &lt; 1000000; ++i) &#123; Foo f; // 构造函数和析构函数分别调用 1000000 次! f.DoSomething(i);&#125; 1234Foo f; // 构造函数和析构函数只调用 1 次for (int i = 0; i &lt; 1000000; ++i) &#123; f.DoSomething(i);&#125; 静态和全局变量 Tip: 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。 静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型(POD : Plain Old Data): 即int,char和float, 以及 POD类型的指针、数组和结构体。 静态变量的构造函数、析构函数和初始化的顺序在C++中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug。所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化POD 变量，除非该函数（比如 getenv() 或 getpid() ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。 综上所述，我们只允许POD类型的静态变量，即完全禁用vector(使用 C 数组替代) 和string(使用const char [])。 小结 cc中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用using关键字污染命名空间 尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元 多线程中的全局变量 (含静态成员变量) 不要使用class类型(含 STL 容器), 避免不明确行为导致的 bug 局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效 类类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项. 构造函数的职责 总述 不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化. 定义 在构造函数中可以进行各种初始化操作. 优点 无需考虑类是否被初始化 经过构造函数完全初始化后的对象可以为const类型, 也能更方便地被标准容器或算法使用 缺点 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患. 如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用bool isValid()或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法. 构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的. 结论 构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用Init()方法或工厂函数. 隐式类型转换 总述 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用explicit关键字. 定义 隐式类型转换允许一个某种类型 (称作 源类型) 的对象被用于需要另一种类型 (称作 目的类型) 的位置, 例如, 将一个int类型的参数传递给需要double类型的函数. explicit关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换,例如使用cast. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法: 123456class Foo &#123; explicit Foo(int x, double y); ...&#125;;void Func(Foo f); 此时下面的代码是不允许的: 1Func(&#123;42, 3.14&#125;); // Error 这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是explicit应当限制的行为. 优点 有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强. 隐式类型转换可以简单地取代函数重载. 在初始化对象时, 列表初始化语法是一种简洁明了的写法. 缺点 隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换. 隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用. 单参数构造函数有可能会被无意地用作隐式类型转换. 如果单参数构造函数没有加上explicit关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上explicit标记. 并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清. 如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候. 结论 在类型定义中, 类型转换运算符和单参数构造函数都应当用explicit进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为explicit, 因为它们并不执行类型转换. 不能以一个参数进行调用的构造函数不应当加上explicit. 接受一个std::initializer_list作为参数的构造函数也应当省略 explicit, 以便支持拷贝初始化 (例如MyType m = {1, 2};) 可拷贝类型和可移动类型 总述 如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用. 定义 可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. string类型就是一个可拷贝类型的例子. 可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). std::unique_ptr&lt;int&gt;就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的. 拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象. 优点 可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器. 拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如Clone(), CopyFrom() or Swap(), 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过= default. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时,对于类似省略不必要的拷贝这样的优化它们也更加合适. 移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰. 缺点 许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型(Registerer), 与特定的作用域相关的类型 (Cleanup), 与其他对象实体紧耦合的类型 (Mutex) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成对象切割. 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误. 拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题. 结论 如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作. 如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的. 12345678class Foo &#123;public: Foo(Foo&amp;&amp; other) : field_(other.field) &#123;&#125; // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.private: Field field_;&#125;; 由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个public virtual Clone()和一个protected的拷贝构造函数以供派生类实现. 如果你的类不需要拷贝 / 移动操作, 请显式地通过在public域中使用= delete或其他手段禁用之. 123// MyClass is neither copyable nor movable.MyClass(const MyClass&amp;) = delete;MyClass&amp; operator=(const MyClass&amp;) = delete; 结构体 VS 类 总述 仅当只有数据成员时使用struct, 其它一概使用class. 说明 在 C++ 中struct和class关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字. struct用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, Initialize(), Reset(), Validate() 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数. 如果需要更多的函数功能, class更适合. 如果拿不准, 就用 class. 为了和STL保持一致, 对于仿函数等特性可以不用class而是使用struct. 注意: 类和结构体的成员变量使用不同的命名规则. 继承 总述 使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承. 定义 当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称. 优点 实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误. 缺点 对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局. 结论 所有继承必须是public的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式. 不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果Bar的确 “是一种” Foo, Bar才能继承Foo. 必要的话, 析构函数声明为virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数. 对于可能被子类访问的成员函数, 不要过度使用protected关键字. 注意, 数据成员都必须是私有的. 对于重载的虚函数或虚析构函数, 使用override, 或 (较不常用的)final关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用virtual关键字作为不得已的选项. 因此, 在声明重载时, 请使用 override, final或virtual的其中之一进行标记. 标记为override或final的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数. 多重继承 总述 真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以Interface为后缀的纯接口类. 定义 多重继承允许子类拥有多个基类. 要将作为纯接口的基类和具有实现的基类区别开来. 优点 相比单继承, 多重实现继承可以复用更多的代码. 缺点 真正需要用到多重 实现 继承的情况少之又少. 有时多重实现继承看上去是不错的解决方案, 但这时你通常也可以找到一个更明确, 更清晰的不同解决方案. 结论 只有当所有父类除第一个外都是纯接口类时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以Interface为后缀. 接口 总述 接口是指满足特定条件的类, 这些类以Interface为后缀 (不强制). 定义 当一个类满足以下要求时, 称之为纯接口: 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数). 没有非静态数据成员. 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为protected. 如果它是一个子类, 也只能从满足上述条件并以Interface为后缀的类继承. 接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 优点 以Interface为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于多重继承尤其重要. 缺点 Interface后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户. 结论 只有在满足上述条件时, 类才以Interface结尾, 但反过来, 满足上述需要的类未必一定以Interface结尾. 运算符重载 总述 除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量. 定义 C++ 允许用户通过使用operator关键字对内建运算符进行重载定义, 只要其中一个参数是用户定义的类型. operator关键字还允许用户使用operator&quot;&quot;定义新的字面运算符, 并且定义类型转换函数, 例如operator bool(). 优点 重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为. 重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如==,&lt;,=,&lt;&lt;), 遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作. 对于创建用户定义的类型的对象来说, 用户定义字面量是一种非常简洁的标记. 缺点 要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug. 过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时. 函数重载有多少弊端, 运算符重载就至少有多少. 运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧. 对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了, 这时需要能够理解 C++ 语法的搜索工具. 重载某些运算符本身就是有害的. 例如, 重载一元运算符 &amp; 会导致同样的代码有完全不同的含义, 这取决于重载的声明对某段代码而言是否是可见的. 重载诸如&amp;&amp;,||和, 会导致运算顺序和内建运算的顺序不一致. 结论 只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, | 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道. 只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, .cc中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, 请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了&lt;, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数,&lt;和&gt;不会同时返回true. 不要为了避免重载操作符而走极端. 比如说, 应当定义==,=,和&lt;&lt;而不是Equals(),CopyFrom()和PrintTo(). 反过来说, 不要只是为了满足函数库需要而去定义运算符重载. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入std::set中, 最好还是定义一个自定义的比较运算符而不是重载&lt;. 不要重载&amp;&amp;,||,,或一元运算符&amp;. 不要重载operator&quot;&quot;, 也就是说, 不要引入用户定义字面量. 存取控制 总述 将所有数据成员声明为private, 除非是static const类型成员 (遵循 常量命名规则). 处于技术上的原因, 在使用Google Test时我们允许测试固件类中的数据成员为protected. 声明顺序 总述 将相似的声明放在一起, 将public部分放在最前. 说明 类定义一般应以public:开始, 后跟protected:, 最后是private:. 省略空部分. 在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括typedef,using和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员. 不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 参见 内联函数 一节. 小结 不在构造函数中做太多逻辑相关的初始化 编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数 为避免隐式转换, 需将单参数构造函数声明为explicit 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为private且无需实现 仅在作为数据集合时使用struct 组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明virtual关键字, 虽然编译器允许不这样做 避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口 接口类类名以Interface为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为protected 为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明 存取函数一般内联在头文件中 声明次序:public -&gt; protected -&gt; private 函数体尽量短小, 紧凑, 功能单一 函数参数顺序 总述 函数的参数顺序为: 输入参数在先, 后跟输出参数. 说明 C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或const引用, 输出参数或输入/输出参数则一般为非const指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前. 这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通. 编写简短函数 总述 我们倾向于编写简短, 凝练的函数. 说明 我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过40行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割. 即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短,以便于他人阅读和修改代码. 在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用/调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数. 引用参数 总述 所有按引用传递的参数必须加上const. 定义 在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如int foo(int *pval). 在 C++ 中, 函数还可以声明为引用参数: int foo(int &amp;val). 优点 定义引用参数可以防止出现(*pval)++这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针. 缺点 容易引起误解, 因为引用在语法上是值变量却拥有指针的语义. 结论 函数参数列表中, 所有引用参数都必须是const: 1void Foo(const string &amp;in, string *out); 事实上这在Google Code是一个硬性约定: 输入参数是值参或const引用, 输出参数为指针. 输入参数可以是const指针, 但决不能是非const的引用参数, 除非特殊要求, 比如 swap(). 有时候, 在输入形参中用const T*指针比const T&amp;更明智. 比如: 可能会传递空指针. 函数要把指针或对地址的引用赋值给输入形参. 总而言之, 大多时候输入形参往往是const T&amp;. 若用const T*则说明输入另有处理. 所以若要使用const T*, 则应给出相应的理由, 否则会使得读者感到迷惑. 函数重载 总述 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数. 定义 你可以编写一个参数类型为const string&amp;的函数, 然后用另一个参数类型为const char*的函数对其进行重载: 12345class MyClass &#123; public: void Analyze(const string &amp;text); void Analyze(const char *text, size_t textlen);&#125;; 优点 通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利. 缺点 如果函数单靠不同的参数类型而重载, 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑. 结论 如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用AppendString()和AppendInt()等, 而不是一口气重载多个Append(). 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用std::vector以便使用者可以用 列表初始化 指定参数. 缺省参数 总述 只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 函数重载 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下. 优点 有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”. 缺点 缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 不应当使用函数重载的理由 也都适用于缺省参数. 虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数. 缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值. 缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题. 结论 对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像void f(int n = counter++); 这样的代码.) 在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载. 来自Google的奇技Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同. 所有权与智能指针 总述 动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权. 定义 所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象. 智能指针是一个通过重载*和-&gt;运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位.std::unique_ptr是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当std::unique_ptr离开作用域时, 对象就会被销毁.std::unique_ptr不能被复制, 但可以把它移动（move）给新所有主.std::shared_ptr同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁. 优点 如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存. 传递对象的所有权, 开销比复制来得小, 如果可以复制的话. 传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作. 如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升. 可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼. 对于 const 对象来说, 智能指针简单易用, 也比深度复制高效. 缺点 不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题. 其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失. 如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型. 如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显. std::unique_ptr的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员. 如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统. 所有权共享机制的登记工作在运行时进行, 开销可能相当大. 某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁. 智能指针并不能够完全代替原生指针. 结论 如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用std::unique_ptr来明确所有权传递, 例如： 12std::unique_ptr&lt;Foo&gt; FooFactory();void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr); 如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说std::shared_ptr&lt;const Foo&gt;）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用std::shared_ptr. 不要使用std::auto_ptr, 使用std::unique_ptr代替它. Cpplint 总述 使用cpplint.py检查风格错误. 说明 cpplint.py是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加// NOLINT, 或在上一行加// NOLINTNEXTLINE, 可以忽略报错. 某些项目会指导你如何使用他们的项目工具运行cpplint.py. 如果你参与的项目没有提供, 你可以单独下载cpplint.py. 其他C++特性引用参数 Tip: 所有按引用传递的参数必须加上const. 定义 在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如int foo(int *pval). 在 C++ 中, 函数还可以声明引用参数:int foo(int &amp;val). 优点 定义引用参数防止出现(*pval)++这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受NULL指针. 缺点 容易引起误解, 因为引用在语法上是值变量却拥有指针的语义. 结论 函数参数列表中, 所有引用参数都必须是const: 1void Foo(const string &amp;in, string *out); 事实上这在 Google Code 是一个硬性约定: 输入参数是值参或const引用, 输出参数为指针. 输入参数可以是const指针, 但决不能是非const的引用参数，除非用于交换，比如swap(). 有时候，在输入形参中用const T*指针比const T&amp;更明智。比如： - 您会传 null 指针。 - 函数要把指针或对地址的引用赋值给输入形参。 总之大多时候输入形参往往是const T&amp;. 若用const T*说明输入另有处理。所以若您要用 const T*, 则应有理有据，否则会害得读者误解。 右值引用 Tip: 只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用std::forward. 定义 右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如,void f(string&amp;&amp; s); 声明了一个其参数是一个字符串的右值引用的函数. 优点 用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果v1是一个vector&lt;string&gt;, 则auto v2(std::move(v1))将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升. 缺点 右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的. 结论 只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用std::forward功能函数. 你可能会使用std::move来表示将值从一个对象移动而不是复制到另一个对象. 函数重载 Tip: 若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。 定义 你可以编写一个参数类型为const string&amp;的函数, 然后用另一个参数类型为const char*的函数重载它: 12345class MyClass &#123; public: void Analyze(const string &amp;text); void Analyze(const char *text, size_t textlen);&#125;; 优点 通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利. 缺点 如果函数单单靠不同的参数类型而重载，读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。 结论 如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用AppendString()和AppendInt()等， 而不是一口气重载多个Append(). 缺省参数 Tip: 我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。 优点 当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。 缺点 缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。 结论 由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数。 位于.cc文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了 可以在构造函数里用缺省参数，毕竟不可能取得它们的地址 可以用来模拟变长数组 变长数组和alloca() Tip: 我们不允许使用变长数组和alloca(). 优点 变长数组具有浑然天成的语法. 变长数组和alloca()也都很高效. 缺点 变长数组和alloca()不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”. 结论 改用更安全的分配器（allocator），就像std::vector或std::unique_ptr&lt;T[]&gt;. 友元 Tip: 我们允许合理的使用友元类及友元函数. 通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将FooBuilder声明为Foo的友元, 以便FooBuilder正确构造 Foo 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便. 友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为public, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作. 运行时类型识别 Tip: 禁止使用 RTTI(Run-Time Type Identification). 定义 RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用typeid或者dynamic_cast完成. 优点 RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中. RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用. 在考虑多个抽象对象时 RTTI 也很好用. 例如: 1234567bool Base::Equal(Base* other) = 0;bool Derived::Equal(Base* other) &#123;Derived* that = dynamic_cast&lt;Derived*&gt;(other);if (that == NULL) return false;...&#125; 缺点 在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类. 随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们. 结论 基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样: 123456if (typeid(*data) == typeid(D1)) &#123;...&#125; else if (typeid(*data) == typeid(D2)) &#123;...&#125; else if (typeid(*data) == typeid(D3)) &#123;... 一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块. 不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图. 类型转换 Tip: 使用 C++ 的类型转换, 如static_cast&lt;&gt;(). 不要使用int y = (int)x或int y = int(x)等转换方式 定义 C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类. 优点 C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 (int)3.5), 有时是在做类型转换 (如 (int)&quot;hello&quot;). 另外, C++ 的类型转换在查找时更醒目. 结论 不要使用 C 风格类型转换. 而应该使用 C++ 风格. 用static_cast替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时. 用const_cast去掉const限定符. 用reinterpret_cast指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用. 流 Tip: 只在记录日志时使用流. 定义 流用来替代printf()和scanf(). 优点 有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用printf也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件. 缺点 流使得pread()等功能函数很难执行. 如果不使用printf风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 %.*s) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用. 结论 不要使用流, 除非是日志接口需要. 使用printf之类的代替. 使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流. 前置自增和自减减 Tip: 对于迭代器和其他模板对象使用前缀形式(++i)的自增, 自减运算符. 定义 对于变量在自增 (++i或i++) 或自减 (--i或i--) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减). 优点 不考虑返回值的话, 前置自增 (++i) 通常要比后置自增 (i++) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝. 如果 i 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢? 缺点 在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在for循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (i) 在谓语动词 (++) 前. 结论 对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减). const用法 Tip: 我们强烈建议你在任何可能的情况下都要使用const. 此外有时改用 C++11 推出的 constexpr 更好。 定义 在声明的变量或参数前加上关键字const用于指明变量值不可被篡改 (如 const int foo). 为类中的函数加上const限定符表明该函数不会修改类成员变量的状态 (如class Foo { int Bar(char c) const; };). 优点 大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的. 缺点 const是入侵性的: 如果你向一个函数传入const变量, 函数原型声明中也必须对应const参数 (否则变量需要const_cast类型转换), 在调用库函数时显得尤其麻烦. 结论 const变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用const: 如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 const. 尽可能将函数声明为const. 访问函数应该总是const. 其他不会修改任何数据成员, 未调用非const函数, 不会返回数据成员非 const指针或引用的函数也应该声明成const. 如果数据成员在对象构造之后不再发生变化, 可将其定义为const. constexpr用法 Tip: 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。 定义 变量可以被声明成constexpr以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成constexpr, 以用来定义 constexpr变量。 优点 如今 constexpr 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。 缺点 若过早把变量优化成 constexpr 变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。 结论 靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。 千万别痴心妄想地想靠 constexpr 来强制代码「内联」。 预处理宏 Tip: 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之. 宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域. 值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被const变量代替. 用宏 “缩写” 长变量名可被引用代替. 用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦 (#define防止头文件重包含当然是个特例). 宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用#字符串化, 用##连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的. 下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守: 不要在.h文件中定义宏. 在马上要使用时才进行#define, 使用后要立即 #undef. 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称； 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为. 不要用##处理函数，类和变量的名字。 nullptr和NULL Tip: 对于指针 (地址值), 到底是用0,NULL还是nullptr. C++11 项目用nullptr; C++03 项目则用NULL, 毕竟它看起来像指针。实际上，一些 C++ 编译器对NULL的定义比较特殊，可以输出有用的警告，特别是 sizeof(NULL)就和sizeof(0)不一样。 sizeof Tip: 尽可能用sizeof(varname)代替sizeof(type).使用sizeof(varname)是因为当代码中变量类型改变时会自动更新. 您或许会用sizeof(type)处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。 auto Tip: 用auto绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。 定义 C++11 中，若变量被声明成auto, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用auto来复制初始化或绑定引用。 1234vector&lt;string&gt; v;...auto s1 = v[0]; // 创建一份 v[0] 的拷贝。const auto&amp; s2 = v[0]; // s2 是 v[0] 的一个引用。 优点 C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像： 1sparse_hash_map&lt;string, int&gt;::iterator iter = m.find(val); 返回类型好难读，代码目的也不够一目了然。重构其： 1auto iter = m.find(val); 好多了。 没有auto的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像： 1diagnostics::ErrorStatus* status = new diagnostics::ErrorStatus("xyz"); 有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。 缺点 类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了： 1auto i = x.Lookup(key); 看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。 程序员必须会区分auto和const auto&amp;的不同之处，否则会复制错东西。 auto 和 C++11 列表初始化的合体令人摸不着头脑： 12auto x(3); // 圆括号。auto y&#123;3&#125;; // 大括号。 它们不是同一回事——x是int,y则是std::initializer_list&lt;int&gt;. 其它一般不可见的代理类型也有大同小异的陷阱。 如果在接口里用auto, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。 结论 auto只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化auto变量。 auto还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在lambda表达式里。 列表初始化早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体： 12struct Point &#123; int x; int y; &#125;;Point p = &#123;1, 2&#125;; C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下： 12345678910111213141516171819// Vector 接收了一个初始化列表。vector&lt;string&gt; v&#123;"foo", "bar"&#125;;// 不考虑细节上的微妙差别，大致上相同。// 您可以任选其一。vector&lt;string&gt; v = &#123;"foo", "bar"&#125;;// 可以配合 new 一起用。auto p = new vector&lt;string&gt;&#123;"foo", "bar"&#125;;// 初始化列表也可以用在返回类型上的隐式转换。vector&lt;int&gt; test_function() &#123; return &#123;1, 2, 3&#125;; &#125;// 初始化列表可迭代。for (int i : &#123;-1, -2, -3&#125;) &#123;&#125;// 在函数调用里用列表初始化。void TestFunction2(vector&lt;int&gt; v) &#123;&#125;TestFunction2(&#123;1, 2, 3&#125;); 用户自定义类型也可以定义接收std::initializer_list&lt;T&gt;的构造函数和赋值运算符，以自动列表初始化： 12345678910111213class MyType &#123; public: // std::initializer_list 专门接收 init 列表。 // 得以值传递。 MyType(std::initializer_list&lt;int&gt; init_list) &#123; for (int i : init_list) append(i); &#125; MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) &#123; clear(); for (int i : init_list) append(i); &#125;&#125;;MyType m&#123;2, 3, 5, 7&#125;; 最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收std::initializer_list&lt;T&gt;的构造函数。 1234567891011double d&#123;1.23&#125;;// MyOtherType 没有 std::initializer_list 构造函数， // 直接上接收常规类型的构造函数。class MyOtherType &#123; public: explicit MyOtherType(string); MyOtherType(int, string);&#125;;MyOtherType m = &#123;1, "b"&#125;;// 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。MyOtherType m&#123;"b"&#125;; Lambda表达式 Tip: 适当使用lambda表达式。别用默认lambda捕获，所有捕获都要显式写出来。 定义 Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如： 123std::sort(v.begin(), v.end(), [](int x, int y) &#123; return Weight(x) &lt; Weight(y);&#125;); C++11 首次提出 Lambdas, 还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper）std::function. 优点 传函数对象给 STL 算法，Lambdas 最简易，可读性也好。 Lambdas,std::functions和std::bind可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。 缺点 Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。 Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。 结论 按 format 小用 lambda 表达式怡情。 禁用默认捕获([=] [&amp;])，捕获都要显式写出来。打比方，比起[=](int x) {return x + n;}, 您该写成[n](int x) {return x + n;}才对，这样读者也好一眼看出n是被捕获的值。 匿名函数始终要简短，如果函数体超过了五行，那么还不如起名，或改用函数。 如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto. 命名约定最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则. 命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则. 通用命名规则 总述 函数命名, 变量命名, 文件命名要有描述性; 少用缩写 说明 尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词. 123int price_count_reader; // 无缩写int num_errors; // "num" 是一个常见的写法int num_dns_connections; // 人人都知道 "DNS" 是什么 123456int n; // 毫无意义.int nerr; // 含糊不清的缩写.int n_comp_conns; // 含糊不清的缩写.int wgc_connections; // 只有贵团队知道是什么意思.int pc_reader; // "pc" 有太多可能的解释了.int cstmr_id; // 删减了若干字母. 注意, 一些特定的广为人知的缩写是允许的, 例如用 i 表示迭代变量和用 T 表示模板参数. 文件命名 总述 文件名要全部小写, 可以包含下划线_或连字符-, 依照项目的约定. 如果没有约定, 那么_更好. 说明 可接受的文件命名示例: my_useful_class.cc my-useful-class.cc myusefulclass.cc myusefulclass_test.cc // _unittest 和 _regtest 已弃用 C++ 文件要以.cc结尾, 头文件以.h结尾. 专门插入文本的文件则以.inc结尾 不要使用已经存在于/usr/include下的文件名, 如db.h. 通常应尽量让文件名更加明确.http_server_logs.h就比logs.h要好. 定义类时文件名一般成对出现, 如foo_bar.h和foo_bar.cc, 对应于类FooBar. 内联函数必须放在.h文件中. 如果内联函数比较短, 就直接放在.h中. 类型命名 总述 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum. 说明 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如: 12345678910111213// 类和结构体class UrlTable &#123; ...class UrlTableTester &#123; ...struct UrlTableProperties &#123; ...// 类型定义typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// using 别名using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;// 枚举enum UrlTableErrors &#123; ... 变量命名 总述 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_. 说明 普通变量命名 123string table_name; // 好 - 用下划线.string tablename; // 好 - 全小写.string tableName; // 差 - 混合大小写 类数据成员 1234567class TableInfo &#123; ... private: string table_name_; // 好 - 后加下划线. string tablename_; // 好. static Pool&lt;TableInfo&gt;* pool_; // 好.&#125;; - 结构体变量 12345struct UrlTableProperties &#123; string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool;&#125;; 常量命名 总述 声明为constexpr或const的变量, 或在程序运行期间其值始终保持不变的,命名时以 “k” 开头, 大小写混合. 例如: 1const int kDaysInAWeek = 7; 说明 所有具有静态存储类型的变量 (例如静态变量或全局变量) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则. 函数命名 总述 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable(). 说明 一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作StartRpc()而非StartRPC()). 123AddTableEntry()DeleteUrl()OpenFileOrDie() 取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如int count()与void set_count(int count). 命名空间命名 总述 命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突. 顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中. 要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的std命名空间. 建议使用更独特的项目标识符 (websearch::index,websearch::index_util) 而非常见的极易发生冲突的名称 (比如websearch::util). 对于internal命名空间, 要当心加入到同一internal命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于frobber.h, 使用websearch::index::frobber_internal). 枚举命名 总述 枚举的命名应当和 常量 或 宏 一致: kEnumName或是ENUM_NAME. 说明 单独的枚举值应该优先采用 常量 的命名方式. 但 宏 方式的命名也可以接受. 枚举名UrlTableErrors(以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式. 12345678910enum UrlTableErrors &#123; kOK = 0, kErrorOutOfMemory, kErrorMalformedInput,&#125;;enum AlternateUrlTableErrors &#123; OK = 0, OUT_OF_MEMORY = 1, MALFORMED_INPUT = 2,&#125;; 宏命名你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 注释注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字. 注释风格 总述 使用//或/* */, 统一就好. 说明 //或/* */都可以; 但//更 常用. 要在如何注释及注释风格上确保统一. 文件注释 总述 在每一个文件开头加入版权公告. 文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释. 说明 法律公告和作者信息 每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL) 如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息. 文件内容 如果一个.h文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系. 一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中. 不要在.h和.cc之间复制注释, 这样的注释偏离了注释的实际意义. 类注释 总述 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显. 12345678910// Iterates over the contents of a GargantuanTable.// Example:// GargantuanTableIterator* iter = table-&gt;NewIterator();// for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) &#123;// process(iter-&gt;key(), iter-&gt;value());// &#125;// delete iter;class GargantuanTableIterator &#123;...&#125;; 说明 类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用. 如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适. 如果类的声明和定义分开了(例如分别放在了.h和.cc文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起. 函数注释 总述 函数声明处的注释描述函数功能; 定义处的注释描述函数实现. 说明 函数说明 基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情. 函数声明处注释的内容: 函数的输入输出. 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数. 函数是否分配了必须由调用者释放的空间. 参数是否可以为空指针. 是否存在函数使用上的性能隐患. 如果函数是可重入的, 其同步前提是什么? 举例如下 123456789101112131415// Returns an iterator for this table. It is the client's// responsibility to delete the iterator when it is done with it,// and it must not use the iterator once the GargantuanTable object// on which the iterator was created has been deleted.//// The iterator is initially positioned at the beginning of the table.//// This method is equivalent to:// Iterator* iter = table-&gt;NewIterator();// iter-&gt;Seek("");// return iter;// If you are going to immediately seek to another place in the// returned iterator, it will be faster to use NewIterator()// and avoid the extra seek.Iterator* GetIterator() const; 但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了: 12// Returns true if the table cannot hold any more entries.bool IsTableFull(); 注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释. 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释. 注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的. 函数定义 如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要. 不要 从.h文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上. 变量注释 总述 通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明. 说明 类数据成员 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释. 特别地, 如果变量可以接受NULL或-1等警戒值, 须加以说明. 比如: 1234private:// Used to bounds-check table accesses. -1 means// that we don't yet know how many entries the table has.int num_total_entries_; 全局变量 和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因. 比如: 12// The total number of tests cases that we run through in this regression test.const int kNumTestCases = 6; 实现注释 总述 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释. 说明 代码前注释 巧妙或复杂的代码段前要加注释. 比如: 1234567// Divide result by two, taking into account that x// contains the carry from the add.for (int i = 0; i &lt; result-&gt;size(); i++) &#123;x = (x &lt;&lt; 8) + (*result)[i];(*result)[i] = x &gt;&gt; 1;x &amp;= 1;&#125; 行注释 比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如: 1234// If we have enough memory, mmap the data portion too.mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))return; // Error already logged. 注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志. 函数参数注释 如果函数参数的意义不明显, 考虑用下面的方式进行弥补: 如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破. 考虑更改函数的签名, 让某个bool类型的参数变为enum类型, 这样可以让这个参数的值表达其意义. 如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改. 用具名变量代替大段而复杂的嵌套表达式. 万不得已时, 才考虑在调用点用注释阐明参数的意义. 不允许的行为 不要描述显而易见的现象, 永远不要用自然语言翻译代码作为注释, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意: 你所提供的注释应当解释代码为什么要这么做和代码的目的, 或者最好是让代码自文档化. 比较这样的注释: 12345// Find the element in the vector. &lt;-- 差: 这太明显了!auto iter = std::find(v.begin(), v.end(), element);if (iter != v.end()) &#123; Process(element);&#125; 和这样的注释: 12345// Process "element" unless it was already processed.auto iter = std::find(v.begin(), v.end(), element);if (iter != v.end()) &#123; Process(element);&#125; 自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的: 123if (!IsAlreadyProcessed(element)) &#123; Process(element);&#125; TODO注释 总述 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用TODO注释. TODO注释要使用全大写的字符串TODO,在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一TODO相关的 issue. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的TODO格式进行查找. 添加TODO注释并不意味着你要自己来修正, 因此当你加上带有姓名的TODO时, 一般都是写上自己的名字. 123// TODO(kl@gmail.com): Use a "*" here for concatenation operator.// TODO(Zeke) change this to use relations.// TODO(bug 12345): remove the "Last visitors" feature 如果加TODO是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”). 小结 关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释 文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你 注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的 对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗 注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了 格式行长度 总述 每一行代码字符数不超过 80. 我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要. 优点 提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢? 缺点 反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码. 结论 80 个字符是最大值. 如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符. 包含长路径的#include语句可以超出80列. 非ASCII字符 总述 尽量不使用非 ASCII 字符, 使用时必须使用UTF-8编码. 说明 即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码. 空格还是制表位 总述 只使用空格, 每次缩进2个空格.（如果你所在的项目使用4各空格缩进，那么请保持一致性） 说明 我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格. 函数声明与定义 总述 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与函数调用一致. 说明 函数看上去像这样: 1234ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123; DoSomething(); ...&#125; 如果同一行文本太多, 放不下所有参数: 12345ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) &#123; DoSomething(); ...&#125; 甚至连第一个参数都放不下: 1234567ReturnType LongClassName::ReallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) &#123; DoSomething(); // 2 space indent ...&#125; 注意以下几点： 使用好的参数名. 只有在参数未被使用或者其用途非常明显时, 才能省略参数名. 如果返回类型和函数名在一行放不下, 分行. 如果返回类型与函数声明或定义分行了, 不要缩进. 左圆括号总是和函数名在同一行. 函数名和左圆括号间永远没有空格. 圆括号与参数间没有空格. 左大括号{总在最后一个参数同一行的末尾处, 不另起新行. 右大括号总是单独位于函数最后一行, 或者与左大括号同一行. 右圆括号和左大括号间总是有一个空格. 所有形参应尽可能对齐. 缺省缩进为 2 个空格. 换行后的参数保持 4 个空格的缩进. 未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名: 1234567class Foo &#123; public: Foo(Foo&amp;&amp;); Foo(const Foo&amp;); Foo&amp; operator=(Foo&amp;&amp;); Foo&amp; operator=(const Foo&amp;);&#125;; 未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来: 1234567891011class Shape &#123; public: virtual void Rotate(double radians) = 0;&#125;;class Circle : public Shape &#123; public: void Rotate(double radians) override;&#125;;void Circle::Rotate(double /*radians*/) &#123;&#125; 12// 差 - 如果将来有人要实现, 很难猜出变量的作用.void Circle::Rotate(double) &#123;&#125; 属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前: 1MUST_USE_RESULT bool IsOK(); Lambda表达式 总述 Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开. 说明 若用引用捕获, 在变量名和&amp;之间不留空格. 12int x = 0;auto add_to_x = [&amp;x](int n) &#123; x += n; &#125;; 短 lambda 就写得和内联函数一样. 123456std::set&lt;int&gt; blacklist = &#123;7, 8, 9&#125;;std::vector&lt;int&gt; digits = &#123;3, 9, 1, 8, 4, 7, 1&#125;;digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) &#123; return blacklist.find(i) != blacklist.end(); &#125;), digits.end()); 函数调用 总述 要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里. 说明 函数调用遵循如下形式 1bool retval = DoSomething(argument1, argument2, argument3); 如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格： 12bool retval = DoSomething(averyveryveryverylongargument1, argument2, argument3); 参数也可以放在次行, 缩进四格： 12345678if (...) &#123; ... ... if (...) &#123; DoSomething( argument1, argument2, // 4 空格缩进 argument3, argument4);&#125; 如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数： 12int my_heuristic = scores[x] * y + bases[x];bool retval = DoSomething(my_heuristic, x, y, z); 或者放着不管, 补充上注释： 12bool retval = DoSomething(scores[x] * y + bases[x], // Score heuristic. x, y, z); 如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. 参数的格式处理应当以可读性而非其他作为最重要的原则. 此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式： 1234// 通过 3x3 矩阵转换 widget.my_widget.Transform(x1, x2, x3, y1, y2, y3, z1, z2, z3); 列表初始化如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字, 就视作名字长度为零. 12345678910111213141516171819202122232425// 一行列表初始化示范.return &#123;foo, bar&#125;;functioncall(&#123;foo, bar&#125;);pair&lt;int, int&gt; p&#123;foo, bar&#125;;// 当不得不断行时.SomeFunction( &#123;"assume a zero-length name before &#123;"&#125;, // 假设在 &#123; 前有长度为零的名字. some_other_function_parameter);SomeType variable&#123; some, other, values, &#123;"assume a zero-length name before &#123;"&#125;, // 假设在 &#123; 前有长度为零的名字. SomeOtherType&#123; "Very long string requiring the surrounding breaks.", // 非常长的字符串, 前后都需要断行. some, other values&#125;, SomeOtherType&#123;"Slightly shorter string", // 稍短的字符串. some, other, values&#125;&#125;;SomeType variable&#123; "This is too long to fit all in one line"&#125;; // 字符串过长, 因此无法放在同一行.MyType m = &#123; // 注意了, 您可以在 &#123; 前断行. superlongvariablename1, superlongvariablename2, &#123;short, interior, list&#125;, &#123;interiorwrappinglist, interiorwrappinglist2&#125;&#125;; 条件语句 总述 倾向于不在圆括号内使用空格. 关键字if和else另起一行. 说明 对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有. 最常见的是没有空格的格式. 哪一种都可以, 最重要的是保持一致. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了. 1234567if (condition) &#123; // 圆括号里没有空格. ... // 2 空格缩进.&#125; else if (...) &#123; // else 与 if 的右括号同一行. ...&#125; else &#123; ...&#125; 注意所有情况下if和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格: 1234if(condition) // 差 - IF 后面没空格.if (condition)&#123; // 差 - &#123; 前面没空格.if(condition)&#123; // 变本加厉地差.if (condition) &#123; // 好 - IF 和 &#123; 都与空格紧邻. 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用else子句时使用: 12if (x == kFoo) return new Foo();if (x == kBar) return new Bar(); 如果语句有else分支则不允许: 123// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行if (x) DoThis();else DoThat(); 通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求if必须总是使用大括号: 123456if (condition) DoSomething(); // 2 空格缩进.if (condition) &#123; DoSomething(); // 2 空格缩进.&#125; 但如果语句中某个if-else分支使用了大括号的话, 其它分支也必须使用: 123456789101112// 不可以这样子 - IF 有大括号 ELSE 却没有.if (condition) &#123; foo;&#125; else bar;// 不可以这样子 - ELSE 有大括号 IF 却没有.if (condition) foo;else &#123; bar;&#125; 123456// 只要其中一个分支用了大括号, 两个分支都要用上大括号.if (condition) &#123; foo;&#125; else &#123; bar;&#125; 循环和开关选择语句 总述 switch语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用{}或continue. 说明 switch语句中的case块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法. 如果有不满足case条件的枚举值, switch应该总是包含一个default匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果default应该永远执行不到, 简单的加条 assert: 12345678910111213switch (var) &#123; case 0: &#123; // 2 空格缩进 ... // 4 空格缩进 break; &#125; case 1: &#123; ... break; &#125; default: &#123; assert(false); &#125;&#125; 在单语句循环里, 括号可用可不用： 123456for (int i = 0; i &lt; kSomeNumber; ++i) printf("I love you\n");for (int i = 0; i &lt; kSomeNumber; ++i) &#123; printf("I take it back\n");&#125; 空循环体应使用{}或continue, 而不是一个简单的分号. 12345while (condition) &#123; // 反复循环直到条件失效.&#125;for (int i = 0; i &lt; kSomeNumber; ++i) &#123;&#125; // 可 - 空循环体.while (condition) continue; // 可 - contunue 表明没有逻辑. 指针和引用表达式 总述 句点或箭头前后不要有空格. 指针/地址操作符 (*, &amp;) 之后不能有空格. 说明 下面是指针和引用表达式的正确使用范例: 1234x = *p;p = &amp;x;x = r.y;x = r-&gt;y; 注意 在访问成员时, 句点或箭头前后没有空格. 指针操作符 * 或 &amp; 后没有空格. 在声明指针变量或参数时, 星号与类型或变量名紧挨都可以: 1234567// 好, 空格前置.char *c;const string &amp;str;// 好, 空格后置.char* c;const string&amp; str; 123int x, *y; // 不允许 - 在多重声明中不能使用 &amp; 或 *char * c; // 差 - * 两边都有空格const string &amp; str; // 差 - &amp; 两边都有空格. 在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格. 布尔表达式 总述 如果一个布尔表达式超过标准行宽, 断行方式要统一一下. 说明 下例中, 逻辑与 (&amp;&amp;) 操作符总位于行尾: 12345if (this_one_thing &gt; this_other_thing &amp;&amp; a_third_thing == a_fourth_thing &amp;&amp; yet_another &amp;&amp; last_one) &#123; ...&#125; 函数返回值 总述 不要在return表达式里加上非必须的圆括号. 说明 只有在写x = expr要加上括号的时候才在return expr;里使用括号. 1234return result; // 返回值很简单, 没有圆括号.// 可以用圆括号把复杂表达式圈起来, 改善可读性.return (some_long_condition &amp;&amp; another_condition); 变量及数组初始化 总述 用=,()和{}均可. 说明 您可以用=,()和{}, 以下的例子都是正确的： 123456int x = 3;int x(3);int x&#123;3&#125;;string name("Some Name");string name = "Some Name";string name&#123;"Some Name"&#125;; 请务必小心列表初始化{...}用std::initializer_list构造函数初始化出的类型. 非空列表初始化就会优先调用std::initializer_list, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用std::initializer_list构造函数, 请改用括号. 12vector&lt;int&gt; v(100, 1); // 内容为 100 个 1 的向量.vector&lt;int&gt; v&#123;100, 1&#125;; // 内容为 100 和 1 的向量. 此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误. 12int pi(3.14); // 好 - pi == 3.int pi&#123;3.14&#125;; // 编译错误: 缩窄转换. 预处理指令 总述 预处理指令不要缩进, 从行首开始. 说明 即使预处理指令位于缩进代码块中, 指令也应从行首开始. 12345678910// 好 - 指令从行首开始 if (lopsided_score) &#123;#if DISASTER_PENDING // 正确 - 从行首开始 DropEverything();# if NOTIFY // 非必要 - # 后跟空格 NotifyClient();# endif#endif BackToNormal(); &#125; 构造函数初始值列表 总述 构造函数初始化列表放在同一行或按四格缩进并排多行. 说明 下面两种初始值列表方式都可以接受: 123456789101112131415161718192021222324// 如果所有变量能放在同一行:MyClass::MyClass(int var) : some_var_(var) &#123; DoSomething();&#125;// 如果不能放在同一行,// 必须置于冒号后, 并缩进 4 个空格MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) &#123; DoSomething();&#125;// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行// 并逐行对齐MyClass::MyClass(int var) : some_var_(var), // 4 space indent some_other_var_(var + 1) &#123; // lined up DoSomething();&#125;// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行// 如果这样做合适的话MyClass::MyClass(int var) : some_var_(var) &#123;&#125; 命名空间格式化 总述 命名空间内容不缩进. 说明 命名空间 不要增加额外的缩进层次, 例如: 1234567namespace &#123;void foo() &#123; // 正确. 命名空间内没有额外的缩进. ...&#125;&#125; // namespace 不要在命名空间内缩进: 12345678namespace &#123; // 错, 缩进多余了. void foo() &#123; ... &#125;&#125; // namespace 声明嵌套命名空间时, 每个命名空间都独立成行. 12namespace foo &#123;namespace bar &#123; 水平留白 总述 水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白. 说明 通用 12345678910111213141516void f(bool b) &#123; // 左大括号前总是有空格. ...int i = 0; // 分号前不加空格.// 列表初始化中大括号内的空格是可选的.// 如果加了空格, 那么两边都要加上.int x[] = &#123; 0 &#125;;int x[] = &#123;0&#125;;// 继承与初始化列表中的冒号前后恒有空格.class Foo : public Bar &#123; public: // 对于单行函数的实现, 在大括号内加上空格 // 然后是函数实现 Foo(int b) : Bar(), baz_(b) &#123;&#125; // 大括号里面是空的话, 不加空格. void Reset() &#123; baz_ = 0; &#125; // 用括号把大括号与实现分开.... 添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). 循环和条件语句 1234567891011121314if (b) &#123; // if 条件语句和循环语句关键字后均有空格.&#125; else &#123; // else 前后有空格.&#125;while (test) &#123;&#125; // 圆括号内部不紧邻空格.switch (i) &#123;for (int i = 0; i &lt; 5; ++i) &#123;switch ( i ) &#123; // 循环和条件语句的圆括号里可以与空格紧邻.if ( test ) &#123; // 圆括号, 但这很少见. 总之要一致.for ( int i = 0; i &lt; 5; ++i ) &#123;for ( ; i &lt; 5 ; ++i) &#123; // 循环里内 ; 后恒有空格, ; 前可以加个空格.switch (i) &#123; case 1: // switch case 的冒号前无空格. ... case 2: break; // 如果冒号有代码, 加个空格. 操作符 1234567891011121314// 赋值运算符前后总是有空格.x = 0;// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.// 圆括号内部没有紧邻空格.v = w * x + y / z;v = w*x + y/z;v = w * (x + z);// 在参数和一元操作符之间不加空格.x = -5;++x;if (x &amp;&amp; !y) ... 模板和转换 123456// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.vector&lt;string&gt; x;y = static_cast&lt;char*&gt;(x);// 在类型与指针操作符之间留空格也可以, 但要保持一致.vector&lt;char *&gt; x; 垂直留白 总述 垂直留白越少越好. 说明 这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行. 基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好. 下面的规则可以让加入的空行更有效: 函数体内开头或结尾的空行可读性微乎其微. 在多重 if-else 块里加空行或许有点可读性. 总结 对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的; 行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去; 80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块, 超多重函数调用等等. 尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了; UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非; 函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行; 除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行; Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号 ./-&gt; 操作符前后不留空格, */&amp; 不要前后都留, 一个就可, 靠左靠右依各人喜好; 预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进; 初始化用=还是()依个人喜好, 统一就好; return不要加(); 水平/垂直留白不要滥用, 怎么易读怎么来.]]></content>
      <categories>
        <category>编码技能</category>
      </categories>
      <tags>
        <tag>代码风格</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake语言和语法]]></title>
    <url>%2FCMake%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CMake在项目或者工作中，会不可避免的使用到cmake来构建我们的项目，所以掌握cmake的基本语法，以及常用的和进阶的使用方法是非常重要的。 下面我们将从一个简单的hello cmake示例开始，一步步的深入了解cmake的用法。 Let’s Go! 初探CMake，hello cmake准备工作创建目录 /home/workspace/cmake_practice，我们之后的练习都放到这个目录的子目录下 在cmake_practice目录下创建test1 123cd /home/workspace/cmake_practicemkdir test1cd test1 创建main.c以及CMakeLists.txt main.c内容如下 1234567include &lt;stdio.h&gt;int main(void)&#123; printf("Hello CMake!\n") return 0;&#125; CMakeLists.txt内容如下 12345PROJECT(hello-cmake)SET(SRC_LIST main.c)MESSAGE(STATUS "This is BINARY dir" $&#123;PROJECT_BINARY_DIR&#125;)MESSAGE(STATUS "This is SOURCE dir" $&#123;PROJECT_SOURCE_DIR&#125;)ADD_EXECUTABLE(hello-cmake $&#123;SRC_LIST&#125;) 开始构建在test1目录下执行cmake .(. 代表当前目录) 这时会在当前目录生成CMakeFiles、cmake_install.cmake、Makefile等文件 我们只要关心Makefile就可以了，此时执行make，我们就得到了可执行文件hello-cmake 运行./hello-cmake 得到输出 Hello CMake! 示例的语法解释cmake的函数可以通过cmake --help-command cmd来查看具体的语法及使用方法 PROJECT 语法： 1project(&lt;projectname&gt; [languageName1 languageName2 ... ] ) 设置项目名称并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。这个指令隐式的定义了两个cmake变量: - &lt;projectname&gt;_BINARY_DIR - &lt;projectname&gt;_SOURCE_DIR 因为采用的是内部编译，两个变量目前指的都是工程所在路径/home/workspace/cmake_practice/test1，后面我们会讲到外部编译，两者所指代的内容会有所不同。 同时 cmake 系统也帮助我们预定义了 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR 变量，他们的值分别跟 &lt;projectname&gt;_BINARY_DIR 与 &lt;projectname&gt;_SOURCE_DIR 一致。 为了统一起见，建议以后直接使用 PROJECT_BINARY_DIR，PROJECT_SOURCE_DIR，即 使修改了工程名称，也不会影响这两个变量。如果使用了 &lt;projectname&gt;_SOURCE_DIR，修改工程名称后，需要同时修改这些变量。 SET 语法： 12SET(&lt;variable&gt; &lt;value&gt; [[CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]] | PARENT_SCOPE]) 在初探阶段，我们只需要知道SET命令可以用来显示的定义一个变量。 比如在这个例子中SET(SRC_LIST main.c)，即定义了一个变量SRC_LIST，此变量的值为main.c。当然如果有多个源文件，可以定义为SET(SRC_LIST main.c test1.c test2.c)。 MESSAGE 语法： 12message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] "message to display" ...) 可选关键字决定消息的类型： none = 重要信息 STATUS = 附带信息 WARNING = CMake警告，继续处理 AUTHOR_WARNING= CMake警告（dev），继续处理 SEND_ERROR = CMake错误，继续处理，但跳过生成 FATAL_ERROR = CMake错误，停止处理和生成 ADD_EXECUTABLE 语法： 123ADD_EXECUTABLE(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) 用于生成可执行的文件，源文件列表为SRC_LIST定义的源文件。在本例中我们使用${}来引用变量，这个cmake的变量使用方式。 基本语法规则本例中使用的基本语法规则有： 变量使用${}方式取值，但是在IF控制语句中是直接使用变量名 COMMAND(param1 param2 …)，参数间用空格或者分号分隔 e.g. ADD(hello-cmake main.c func.c) ADD(hello-cmake main.c;func.c) command是大小写无关的，但是参数和变量是大小写敏感的 内部构建与外部构建在本例中我们使用的是内部构建，即在CMakeLists.txt同级的目录下执行cmake .。内部构建会在SOURCE_DIR下生成很多临时的中间文件，不方便删除，也影响的源代码的阅读。 所以我们推荐外部构建，所谓外部构建就是在一个单独的文件夹下面执行cmake，生成的中间文件和结果都在此文件夹下。 对于本例，使用外部构建过程如下： 首先清除test1目录下除main.c、CMakeLists.txt外的所有文件及文件夹，最关键的是CMakeCache.txt，如果不清除cache，还是会构建到之前的构建目录下。 在test1目录下创建build文件夹 进入build文件夹，执行cmake ..(..代表上一层目录，即CMakeLists所在的文件夹) 运行make，即可在build文件夹下生成对应的可执行文件 上述过程即为out-of-source外部编译。一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。 通过外部编译进行工程构建，PROJECT_SOURCE_DIR仍然指代工程路径，即CMakeLists所在路径，而PROJECT_BINARY_DIR则指代编译路径，即/home/workspace/cmake_practice/test1/build。 小结本结我们通过一个简单的hello cmake示例，介绍了最基本的CMakeLists编写，以及一些基本的语法和命令用法。同时介绍了内部编译和外部编译，及外部编译的好处。 下一节我们将丰富我们的hello cmake示例，使其看起来更像一个项目。 更像一个项目的hello cmake本节的目标是让上一节的hello cmake更像一个项目，我们接下来要做的是: 为工程添加一个子目录，用来放置项目的源代码 添加一个子目录doc，用来工程文档hello.txt 在工程目录添加COPYRIGHT和README 在工程目录添加一个run_hello_cmake.sh脚本，用来调用hello_cmake可执行文件 将构建的结果放置构建目录的bin子目录 最终安装这些文件，将hello_cmake二进制文件以及run_hello_cmake.sh安装至/usr/bin目录下，将doc目录下的文件以及COPYRIGHT、README安装至/usr/share/doc/cmake_practice/test1目录下 准备工作在/home/workspace/cmake_practice目录下建立test2目录，将上一节中的main.c CMakeLists.txt拷贝到test2目录 添加子目录src12mkdir srcmv main.c src 现在工程中有一个子目录src以及CMakeLists.txt。进入子目录，添加CMakeList如下 1ADD_EXECUTABLE(hello_cmake main.c) 将test2工程的CMakeLists修改为 12PROJECT(hello-cmake)ADD_SUBDIRECTORY(src bin) 然后建立build目录，进入build，执行cmake .. &amp; make，构建完成后，目标文件hello-cmake位于build/bin目录下。 语法解释 ADD_SUBDIRECTORY 语法： 12ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。 EXCLUDE_FROM_ALL参数的含义是将这个目录从编译过程中排除，比如，工程的example，可能需要工程构建完成之后，再进入example目录单独进行构建。 上面的例子定义了将src子目录加入工程，并指定了编译输出路径为bin目录。如果不指定bin目录，那么编译的结果都将存放在build/src目录 换个地方保存目标二进制我们可以通过SET指令重新定义EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH变量，来指定最终的目标二进制的位置(指最终生成的 hello_cmake或者最终的共享库，不包含编译生成的中间文件) 12SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_PATH&#125;/bin)SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_PATH&#125;/lib) 在第一节我们提到了&lt;projectname&gt;_BINARY_DIR和PROJECT_BINARY_DIR变量，他们指的编译发生的当前目录，如果是内部编译，就相当于PROJECT_SOURCE_DIR也就是工程代码所在目录，如果是外部编译，指的是外部编译所在目录，也就是本例中的build目录。 所以，上面两个指令分别定义了：可执行二进制的输出路径为build/bin和库的输出路径为build/lib。 至于将这两条指令写在工程的CMakeLists中还是src目录下的CMakeList，只需要按照一个原则：在哪里ADD_EXECUTABLE或ADD_LIBRARY，如果需要改变目标存放的路径，就在其上加入上述定义。 如何安装安装的需要有两种，一种是从代码编译后直接make install安装，一种是打包时的指定目录安装。 那我们的hello_cmake应该怎么进行安装呢？ 这里我们要用到一个新的cmake指令INSTALL和一个非常有用的变量CMAKE_INSTALL_PREFIX CMAKE_INSTALL_PREFIX变量类似于configure脚本的–prefix，常见的使用方法形如： cmake -DCMAKE_INSTALL_PREFIX=/usr . INSTALL指令用于定义安装规则，安装的内容可以包括 目标二进制 动态库 静态库 文件、目录、脚本 INSTALL指令包含了各种安装类型，我们需要一个个分开解释 目标文件的安装 语法： 12345678install(TARGETS targets... [[ARCHIVE|LIBRARY|RUNTIME] [DESTINATION &lt;dir&gt;] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT &lt;component&gt;] [OPTIONAL] ] [...]) 参数中的TARGETS后面跟的就是我们通过ADD_EXECUTABLE或者ADD_LIBRARY定义的目标文件，可能是可执行二进制、动态库、静态库。 目标类型也就相对应的有三种，ARCHIVE特指静态库，LIBRARY特指动态库，RUNTIME特指可执行目标二进制。 DESTINATION定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候CMAKE_INSTALL_PREFIX其实就无效了。如果你希望使用CMAKE_INSTALL_PREFIX来定义安装路径，就要写成相对路径，即不要以/开头，那么安装后的路径就是${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt; e.g. 1234install(TARGETS myExe mySharedLib myStaticLib RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION lib/static) 将会把 myExe安装到${CMAKE_INSTALL_PREFIX}/bin mySharedLib安装到${CMAKE_INSTALL_PREFIX}/lib myStaticLib安装到${CMAKE_INSTALL_PREFIX}/lib/static 普通文件的安装 语法： 12345install(FILES files... DESTINATION &lt;dir&gt; [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT &lt;component&gt;] [RENAME &lt;name&gt;] [OPTIONAL]) 可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限PERMISSIONS，安装后的权限为： OWNER_WRITE, OWNER_READ, GROUP_READ,和 WORLD_READ，即 644 权限 非目标文件的 语法： 12345install(PROGRAMS files... DESTINATION &lt;dir&gt; [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT &lt;component&gt;] [RENAME &lt;name&gt;] [OPTIONAL]) 跟上面的 FILES 指令使用方法一样，唯一的不同是安装后权限为:OWNER_EXECUTE, GROUP_EXECUTE, 和 WORLD_EXECUTE，即 755 权限 目录的安装 语法： 12345678install(DIRECTORY dirs... DESTINATION &lt;dir&gt; [FILE_PERMISSIONS permissions...] [DIRECTORY_PERMISSIONS permissions...] [USE_SOURCE_PERMISSIONS] [OPTIONAL] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT &lt;component&gt;] [FILES_MATCHING] [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;] [EXCLUDE] [PERMISSIONS permissions...]] [...]) 这里主要介绍其中的DIRECTORY、PATTERN、PERMISSIONS参数。 DIRECTORY：后面链接的是所在source目录的相对路径。但是abc和abc/有很大区别。如果目录名不以/结尾，那么这个目录将被安装为目标路径下的abc；如果目录名以/结尾，代表将这个目录中的内容安装到目标路径，但不包括这个目录本身。 PATTERN：用于使用正则表达式进行过滤，PERMISSIONS用于指定PATTERN过滤后的文件权限。 e.g. 12345INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj PATTERN "CVS" EXCLUDE PATTERN "scripts/*" PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ) 这条指令的执行结果是：将icons目录安装到&lt;prefix&gt;/share/myproj，将scripts/中的内容安装到&lt;prefix&gt;/share/myproj不包含目录名为 CVS 的目录，对于 scripts/*文件指定权限为OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ. 安装时CMAKE脚本的执行 语法： 1install([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]] [...]) SCRIPT参数用于在安装时调用cmake脚本文件（也就是&lt;abc&gt;.cmake文件）CODE 参数用于执行CMAKE指令，必须以双引号括起来。比如： INSTALL(CODE &quot;MESSAGE(\&quot;Sample install message.\&quot;)&quot;) 让我们的hello cmake支持安装安装本节开始的要求，下面改写各个目录的CMakeLists 安装COPYRIGHT/README，直接修改主工程文件CMakeLists.txt，加入以下指令：INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake_practice/test2) 安装hello_cmake、run_hello_cmake.sh，修改主工程文件CMakeLists.txt，加入以下指令：INSTALL(PROGRAMS run_hello_cmake.sh DESTINATION bin)；修改src目录下CMakeLists.txt，加入以下命令：INSTALL(PROGRAMS ${PROJECT_BINARY_DIR}/bin/hello_cmake DESTINATION bin) 安装doc中的hello.txt，这里有两种方式：一是通过在 doc 目录建立CMakeLists.txt并将doc目录通过ADD_SUBDIRECTORY加入工程来完成。另一种方法是直接在工程目录通过INSTALL(DIRECTORY 来完成)。我们来尝试后者，顺便演示一下DIRECTORY的安装。因为hello.txt要安装到/&lt;prefix&gt;/share/doc/cmake_practice/test2，所以我们不能直接安装整个doc目录，这里采用的方式是安装doc目录中的内容，也就是使用”doc/“在工程文件中添加INSTALL(DIRECTORY doc/hello.txt DESTINATION share/doc/cmake_practice/test2) 如果没有定义CMAKE_INSTALL_PREFIX，会默认安装到/usr/local下 小结本小节主要描述了如何在工程中使用多目录、各种安装指令以及CMAKE_INSTALL_PREFIX变量。 在下一小节，我们将探讨如何在cmake中构建动态库和静态库，以及如何使用外部头文件和外部共享库。 静态库与动态库静态库与动态库的创建知识点并不多，主要新引入了一个新的命令如下： 123ADD_LIBRARY(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) 类型有三种： SHARED : 动态库 STATIC : 静态库 MODULE : 在使用dyld的系统有效，如果不支持dyld，则被当作SHARED对待 EXCLUDE_FROM_ALL参数的意思是这个库不会被默认构建，除非有其他的组建依赖或者手工构建 名字相同的动态库和静态库同时存在在同一个CMake中，如果ADD_LIBRARY的target名称相同，则后一个目标会覆盖前一个目标。如果我们想让名字相同的静态库和动态库同时存在，需要用到另外一个命令： 123SET_TARGET_PROPERTIES(target1 target2 ... PROPERTIES prop1 value1 prop2 value2 ...) 这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和API版本。 只需要在CMakeLists.txt中加如SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME &quot;hello&quot;)，就可以同时得到libhello.a/libhello.so两个库了。 动态库版本号为了实现动态库版本号，我们仍然需要使用SET_TARGET_PROPERTIES指令。具体使用方法：SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) VERSION指代动态库版本，SOVERSION指代 API 版本。 加如CMakeLists重新构建，在build目录下会生成： 123libhello.so.1.2libhello.so.1-&gt;libhello.so.1.2libhello.so -&gt;libhello.so.1 安装共享库和头文件利用上一节提到的INSTALL指令，我们将动态库以及静态库安装到指定的目录 123INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) 小结本小节，我们谈到了： 如何通过ADD_LIBRARY指令构建动态库和静态库。 如何通过SET_TARGET_PROPERTIES同时构建同名的动态库和静态库。 如何通过SET_TARGET_PROPERTIES控制动态库版本 最终使用上一节谈到的INSTALL指令来安装动态、静态库。 如何使用外部共享库和头文件准备在/home/workspace/cmake_practice目录下建立test4目录，按照上一节，编写CMakeLists，生成自己的hello动态库静态库以及头文件，并安装到/usr/local下。 源文件和CMakeLists重复以前的步骤，建立src目录，编写源文件main.c，内容如下： 123456#include &lt;hello.h&gt;int main()&#123; print_hello(); return 0;&#125; 编写工程主文件CMakeLists.txt 12PROJECT(NEWHELLO)ADD_SUBDIRECTORY(src) 编写src/CMakeLists.txt 1ADD_EXECUTABLE(main main.c) 外部构建按照习惯，仍然建立 build 目录，使用 cmake ..方式构建。过程： 12cmake ..make 构建失败，如果需要查看细节，可以用make VERBOSE=1来构建 错误输出是： 1/home/workspace/cmake_practice/test4/src/main.c:1:19: fatal error: hello.h: No such file or directory 引入头文件搜索路径hello.h位于/usr/local/include/hello目录中，并没有位于系统标准的头文件路径。 为了让我们的工程能够找到hello.h头文件，我们需要引入一个新的指令INCLUDE_DIRECTORIES，其完整语法为： 1include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。 现在我们在src/CMakeLists.txt中添加一个头文件搜索路径，方式很简单，加入：INCLUDE_DIRECTORIES(/usr/local/include/hello) 进入build目录，重新进行构建，这时找不到hello.h的错误已经消失，但是出现了一个新的错误： 1main.c:(.text+0xa): undefined reference to `print_hello&apos; 因为我们并没有link到共享库libhello上 为target添加共享库我们现在需要完成的任务是将目标文件链接到libhello，这里我们需要引入两个新的指令： LINK_DIRECTORIES和TARGET_LINK_LIBRARIES LINK_DIRECTORIES的语法是： 1link_directories(directory1 directory2 ...) 这个指令非常简单，添加非标准的共享库搜索路径，比如，在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。这个例子中我们没有用到这个指令。 TARGET_LINK_LIBRARIES的语法是: 123TARGET_LINK_LIBRARIES(target library1 &lt;debug | optimized&gt; library2 ...) 这个指令可以用来为target添加需要链接的共享库，本例中是一个可执行文件，但是同样可以用于为自己编写的共享库添加共享库链接。 为了解决我们前面遇到的print_hello未定义错误，我们需要作的是向src/CMakeLists.txt中添加如下指令： 12LINK_DIRECTORIES(/usr/local/lib)TARGET_LINK_LIBRARIES(main hello) 这里的hello指的是我们上一节构建的共享库libhello。 进入build目录重新进行构建。 12cmake ..make 这是我们就得到了一个连接到libhello的可执行程序 main，位于 build/src目录，运行main的结果是输出： Hello CMake! 让我们来检查一下main的链接情况： 12345[root@localhost src]# ldd main linux-vdso.so.1 =&gt; (0x00007ffdb59ea000) libhello.so.1 =&gt; /usr/local/lib/libhello.so.1 (0x00007fe24b577000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe24b18e000) /lib64/ld-linux-x86-64.so.2 (0x00007fe24b77a000) 可以清楚的看到main确实链接了共享库libhello，而且链接的是动态库libhello.so.1 那如何链接到静态库呢？方法很简单：将TARGET_LINK_LIBRRARIES指令修改为: TARGET_LINK_LIBRARIES(main libhello.a) 重新构建后再来看一下main的链接情况 1234[root@localhost src]# ldd main linux-vdso.so.1 =&gt; (0x00007fffa2597000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fb216c97000) /lib64/ld-linux-x86-64.so.2 (0x00007fb217080000) 说明main确实链接到了静态库libhello.a。 小结本节我们探讨了: 如何通过INCLUDE_DIRECTORIES指令加入非标准的头文件搜索路径。 如何通过LINK_DIRECTORIES指令加入非标准的库文件搜索路径。 如果通过TARGET_LINK_LIBRARIES为库或可执行二进制加入库链接。 到这里为止，您应该基本可以使用cmake工作了，但是还有很多高级的话题没有探讨，比如编译条件检查、编译器定义、平台判断等等。 到这里，或许你可以理解前面讲到的“cmake的使用过程其实就是学习cmake语言并编写cmake程序的过程”，既然是“cmake语言”，自然涉及到变量、语法等。 下一节，我们将抛开程序的话题，看看常用的CMAKE变量以及一些基本的控制语法规则。 CMake常用变量和常用环境变量使用${}进行变量的引用。在IF等语句中，是直接使用变量名而不通过${}取值。 CMake常用变量 CMAKE_BINARY_DIR PROJECT_BINARY_DIR &lt;projectname&gt;_BINARY_DIR 这三个变量指代的内容是一致的，如果是in source编译，指得就是工程顶层目录，如果是out-of-source编译，指的是工程编译发生的目录。PROJECT_BINARY_DIR跟其他指令稍有区别，现在，你可以理解为他们是一致的。 CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR &lt;projectname&gt;_SOURCE_DIR 这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。也就是在in source编译时，他跟CMAKE_BINARY_DIR等变量一致。PROJECT_SOURCE_DIR跟其他指令稍有区别，现在，你可以理解为他们是一致的。 CMAKE_CURRENT_SOURCE_DIR 指的是当前处理的CMakeLists.txt所在的路径，比如上面我们提到的src子目录。 CMAKE_CURRRENT_BINARY_DIR 如果是in-source编译，它跟CMAKE_CURRENT_SOURCE_DIR一致，如果是out-ofsource编译，他指的是target编译目录。使用我们上面提到的ADD_SUBDIRECTORY(src bin)可以更改这个变量的值。使用SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。 CMAKE_MODULE_PATH 这个变量用来定义自己的 cmake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的，为了让 cmake 在处理CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。比如 1SET(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake) 这时候你就可以通过INCLUDE指令来调用自己的模块了。 CMake调用环境变量使用$ENV{NAME}指令就可以调用系统的环境变量了。 比如 1MESSAGE(STATUS "HOME dir: $ENV&#123;HOME&#125;") 设置环境变量的方式是： SET(ENV{KEY} VALUE) 主要开关选项 BUILD_SHARED_LIBS 这个开关用来控制默认的库编译方式，如果不进行设置，使用 ADD_LIBRARY并没有指定库类型的情况下，默认编译生成的库都是静态库。如果SET(BUILD_SHARED_LIBS ON)后，默认生成的为动态库。 CMAKE_C_FLAGS 设置C编译选项，也可以通过指令ADD_DEFINITIONS()添加。 CMAKE_CXX_FLAGS 设置C++编译选项，也可以通过指令ADD_DEFINITIONS()添加。 CMake常用指令基本指令 ADD_DEFINITIONS 向C/C++编译器添加-D定义，比如:ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)，参数之间用空格分割。如果你的代码中定义了#ifdef ENABLE_DEBUG #endif，这个代码块就会生效。如果要添加其他的编译器开关，可以通过CMAKE_C_FLAGS变量和CMAKE_CXX_FLAGS变量设置 ADD_DEPENDENCIES 定义target依赖的其他target，确保在编译本target之前，其他的 target 已经被构建。 12ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...) ADD_TEST与ENABLE_TESTING ENABLE_TESTING指令用来控制Makefile是否构建test目标，涉及工程所有目录。语法很简单，没有任何参数，ENABLE_TESTING()，一般情况这个指令放在工程的主CMakeLists.txt中。 ADD_TEST指令的语法是:ADD_TEST(testname Exename arg1 arg2 ...) testname是自定义的test名称，Exename可以是构建的目标文件也可以是外部脚本等等。后面连接传递给可执行文件的参数。如果没有在同一个CMakeLists.txt 中打开ENABLE_TESTING()指令，任何ADD_TEST都是无效的。 比如我们前面的Helloworld例子，可以在工程主CMakeLists.txt 中添加 12ADD_TEST(mytest $&#123;PROJECT_BINARY_DIR&#125;/bin/main)ENABLE_TESTING() 生成Makefile后，就可以运行make test来执行测试了。 AUX_SOURCE_DIRECTORY 基本语法：AUX_SOURCE_DIRECTORY(dir VARIABLE) 作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表。因为目前 cmake 还不能自动发现新添加的源文件。 比如 12AUX_SOURCE_DIRECTORY(. SRC_LIST)ADD_EXECUTABLE(main $&#123;SRC_LIST&#125;) 你也可以通过后面提到的FOREACH指令来处理这个LIST CMAKE_MINIMUM_REQUIRED 其语法为CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR]) 比如 CMAKE_MINIMUM_REQUIRED(VERSION 2.5 FATAL_ERROR) 如果cmake版本小与 2.5，则出现严重错误，整个过程中止。 EXEC_PROGRAM 在CMakeLists.txt处理过程中执行命令，并不会在生成的Makefile中执行。具体语法为： 1234EXEC_PROGRAM(Executable [directory in which to run] [ARGS &lt;arguments to executable&gt;] [OUTPUT_VARIABLE &lt;var&gt;] [RETURN_VALUE &lt;var&gt;]) 用于在指定的目录运行某个程序，通过ARGS添加参数，如果要获取输出和返回值，可通过OUTPUT_VARIABLE和RETURN_VALUE分别定义两个变量。 这个指令可以帮助你在CMakeLists.txt处理过程中支持任何命令，比如根据系统情况去修改代码文件等等。 举个简单的例子，我们要在src目录执行ls命令，并把结果和返回值存下来。 可以直接在src/CMakeLists.txt中添加： 1234EXEC_PROGRAM(ls ARGS "*.c" OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE)IF(not LS_RVALUE) MESSAGE(STATUS "ls result: " $&#123;LS_OUTPUT&#125;)ENDIF(not LS_RVALUE) 在cmake生成Makefile的过程中，就会执行ls命令，如果返回0，则说明成功执行，那么就输出 ls *.c 的结果。关于IF语句，后面的控制指令会提到。 FILE FILE(WRITE filename “message to write”… ) FILE(APPEND filename “message to write”… ) FILE(READ filename variable) FILE(GLOB variable [RELATIVE path] [globbing expressions]…) FILE(GLOB_RECURSE variable [RELATIVE path] [globbing expressions]…) FILE(REMOVE [directory]…) FILE(REMOVE_RECURSE [directory]…) FILE(MAKE_DIRECTORY [directory]…) FILE(RELATIVE_PATH variable directory file) FILE(TO_CMAKE_PATH path result) FILE(TO_NATIVE_PATH path result) 这里的语法都比较简单，不在展开介绍了。 INCLUDE 用来载入CMakeLists.txt文件，也用于载入预定义的cmake模块。 12INCLUDE(file1 [OPTIONAL])INCLUDE(module [OPTIONAL]) OPTIONAL参数的作用是文件不存在也不会产生错误。你可以指定载入一个文件，如果定义的是一个模块，那么将在CMAKE_MODULE_PATH中搜索这个模块并载入。载入的内容将在处理到INCLUDE语句是直接执行。 FILE_指令 FIND_FILE( name1 path1 path2 …) VAR 变量代表找到的文件全路径，包含文件名 FIND_LIBRARY( name1 path1 path2 …) VAR 变量表示找到的库全路径，包含库文件名 FIND_PATH( name1 path1 path2 …) VAR 变量代表包含这个文件的路径。 FIND_PROGRAM( name1 path1 path2 …) VAR 变量代表包含这个程序的全路径。 FIND_PACKAGE( [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets…]]) 用来调用预定义在 CMAKE_MODULE_PATH 下的 Find.cmake 模块，你也可以自己定义Find&lt;name&gt;模块，通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录中供工程使用，我们在后面的章节会详细介绍FIND_PACKAGE的使用方法和Find模块的编写。 FIND_LIBRARY 示例： 1234FIND_LIBRARY(libX X11 /usr/lib)IF(NOT libX) MESSAGE(FATAL_ERROR “libX not found”)ENDIF(NOT libX) 控制命令 IF 1234567891011IF(expression) # THEN section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ...ELSE(expression) # ELSE section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ...ENDIF(expression) 另外一个指令是ELSEIF，总体把握一个原则，凡是出现IF的地方一定要有对应的ENDIF。出现 ELSEIF 的地方，ENDIF是可选的。 表达式的使用方法如下: IF(var)，如果变量不是：空，0，N, NO, OFF, FALSE, NOTFOUND 或_NOTFOUND 时，表达式为真。 IF(NOT var )，与上述条件相反。 IF(var1 AND var2)，当两个变量都为真是为真。 IF(var1 OR var2)，当两个变量其中一个为真时为真。 IF(COMMAND cmd)，当给定的 cmd 确实是命令并可以调用是为真。 IF(EXISTS dir)或者 IF(EXISTS file)，当目录名或者文件名存在时为真。 IF(file1 IS_NEWER_THAN file2)，当 file1 比 file2 新，或者 file1/file2 其中有一个不存在时为真，文件名请使用完整路径。 IF(IS_DIRECTORY dirname)，当 dirname 是目录时，为真。 IF(variable MATCHES regex) IF(string MATCHES regex)当给定的变量或者字符串能够匹配正则表达式 regex 时为真。比如： 123IF("hello" MATCHES "ell") MESSAGE("true")ENDIF("hello" MATCHES "ell") 数字比较表达式: IF(variable LESS number) IF(string LESS number) IF(variable GREATER number) IF(string GREATER number) IF(variable EQUAL number) IF(string EQUAL number) 按照字母序的排列进行比较: IF(variable STRLESS string) IF(string STRLESS string) IF(variable STRGREATER string) IF(string STRGREATER string) IF(variable STREQUAL string) IF(string STREQUAL string) IF(DEFINED variable)，如果变量被定义，为真。 一个小例子，用来判断平台差异： 1234567IF(WIN32) MESSAGE(STATUS “This is windows.”) #作一些 Windows 相关的操作ELSE(WIN32) MESSAGE(STATUS “This is not windows”) #作一些非 Windows 相关的操作ENDIF(WIN32) 上述代码用来控制在不同的平台进行不同的控制，但是，阅读起来却并不是那么舒服，ELSE(WIN32)之类的语句很容易引起歧义。 这就用到了我们在“常用变量”一节提到的CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS开关。可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)这时候就可以写成: 123IF(WIN32)ELSE()ENDIF() 如果配合 ELSEIF 使用，可能的写法是这样: 1234567IF(WIN32) #do something related to WIN32ELSEIF(UNIX) #do something related to UNIXELSEIF(APPLE) #do something related to APPLEENDIF(WIN32) WHILE WHILE 指令的语法是： 12345WHILE(condition) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ...ENDWHILE(condition) 其真假判断条件可以参考 IF 指令。 FOREACH FOREACH 指令的使用方法有三种形式： 列表 12345FOREACH(loop_var arg1 arg2 ...) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ...ENDFOREACH(loop_var) 像我们前面使用的AUX_SOURCE_DIRECTORY的例子 1234AUX_SOURCE_DIRECTORY(. SRC_LIST)FOREACH(F $&#123;SRC_LIST&#125;) MESSAGE($&#123;F&#125;)ENDFOREACH(F) 范围 12FOREACH(loop_var RANGE total)ENDFOREACH(loop_var) 从 0 到 total 以1为步进 举例如下： 123456789101112131415FOREACH(VAR RANGE 10)MESSAGE($&#123;VAR&#125;)ENDFOREACH(VAR)最终得到的输出是：012345678910 范围和步进 12FOREACH(loop_var RANGE start stop [step])ENDFOREACH(loop_var) 从start开始到stop结束，以step为步进，举例如下: 123FOREACH(A RANGE 5 15 3) MESSAGE($&#123;A&#125;)ENDFOREACH(A) 最终得到的结果是：5 8 11 14 这个指令需要注意的是，知道遇到ENDFOREACH指令，整个语句块才会得到真正的执行。 模块的使用和自定义模块本章我们将着重介绍系统预定义的Find模块的使用以及自己编写Find模块，系统中提供了其他各种模块，一般情况需要使用INCLUDE指令显式的调用，FIND_PACKAGE指令是一个特例，可以直接调用预定义的模块。 在本章，我们基于我们前面的libhello共享库，编写一个FindHello.cmake模块。 对于系统预定义的Find&lt;name&gt;.cmake模块，每一个模块都会定义以下几个变量： &lt;name&gt;_FOUND &lt;name&gt;_INCLUDE_DIR or &lt;name&gt;_INCLUDES &lt;name&gt;_LIBRARY or &lt;name&gt;_LIBRARIES 你可以通过&lt;name&gt;_FOUND来判断模块是否被找到，如果没有找到，按照工程的需要关闭某些特性、给出提醒或者中止编译。 如果&lt;name&gt;_FOUND为真，则将&lt;name&gt;_INCLUDE_DIR加入INCLUDE_DIRECTORIES，将&lt;name&gt;_LIBRARY加入 TARGET_LINK_LIBRARIES中。 编写FindHello模块我们在此前的test3实例中，演示了构建动态库、静态库的过程并进行了安装。接下来，我们在test6示例中演示如何自定义FindHello模块并使用这个模块构建工程： 请在建立/home/workspace/cmake_practice中建立test6目录，并在其中建立cmake目录用于存放我们自己定义的FindHello.cmake模块，同时建立src目录，用于存放我们的源文件。 定义cmake/FindHello.cmake模块 1234567891011121314FIND_PATH(HELLO_INCLUDE_DIR hello.h /usr/local/include/hello /usr/include/hello)FIND_LIBRARY(HELLO_LIBRARY NAMES hello PATH /usr/local/lib /usr/lib)IF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY) SET(HELLO_FOUND TRUE)ENDIF()IF(HELLO_FOUND) IF(NOT Hello_FIND_QUIETLY) MESSAGE(STATUS "Found Hello: $&#123;HELLO_LIBRARY&#125;") ENDIF()ELSE() IF(Hello_FIND_REQUIRED) MESSAGE(FATAL_ERROR "Cound not find hello library") ENDIF()ENDIF() QUIET参数，对应与我们编写的FindHello中的 HELLO_FIND_QUIETLY，如果不指定这个参数，就会执行：MESSAGE(STATUS &quot;Found Hello: ${HELLO_LIBRARY}&quot;) REQUIRED参数，其含义是指这个共享库是否是工程必须的，如果使用了这个参数，说明这个链接库是必备库，如果找不到这个链接库，则工程不能编译。对应于FindHello.cmake模块中的HELLO_FIND_REQUIRED变量。同样，我们在上面的模块中定义了HELLO_FOUND,HELLO_INCLUDE_DIR,HELLO_LIBRARY变量供开发者在FIND_PACKAGE指令中使用。 在src/main.c中写入如下内容： 123456#include &lt;hello.h&gt;int main()&#123; print_hello(); return 0;&#125; 建立src/CMakeLists.txt文件，内容如下： 123456FIND_PACKAGE(Hello)IF(HELLO_FOUND) ADD_EXECUTABLE(hello main.c) INCLUDE_DIRECTORIES($&#123;HELLO_INCLUDE_DIR&#125;) TARGET_LINK_LIBRARIES(hello $&#123;HELLO_LIBRARY&#125;)ENDIF(HELLO_FOUND) 为了能够让工程找到FindHello.cmake模块(存放在工程中的cmake目录)我们在主工程文件CMakeLists.txt中加入：SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 仍然采用外部编译的方式，建立build目录，进入目录运行： 1cmake .. 我们可以从输出中看到： 1-- Found Hello: /usr/local/lib/libhello.so 如果没有找到hello library呢？ 我们可以尝试将/usr/local/lib/libhello.x 移动到/tmp目录，这样，按照FindHello模块的定义，就找不到hello library了，我们再来看一下构建结果： 1cmake .. 仍然可以成功进行构建，但是这时候是没有办法编译的。修改 FIND_PACKAGE(HELLO)为FIND_PACKAGE(HELLO REQUIRED)，将 hello library定义为工程必须的共享库。 这时候再次运行 cmake .. 我们得到如下输出： CMake Error: Could not find hello library. 因为找不到libhello.x，所以，整个Makefile生成过程被出错中止。]]></content>
      <categories>
        <category>基础知识/技能</category>
      </categories>
      <tags>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于EDCC算法的诞生、原理、效果]]></title>
    <url>%2FEDCC%20Algorithm%2F</url>
    <content type="text"><![CDATA[EDCC(Enhanced and Discriminative Competitive Code): 高效、准确的掌纹识别算法掌纹识别掌纹识别技术的优势作为新崛起的生物特征识别技术之一，掌纹识别可以从分辨率较低的图像中提取出稳定、抗噪能力强且具有识别力的特征。对比其他的生物特征识别技术，掌纹识别技术有以下优势： 与指纹相比，掌纹的识别面积更大，包含的信息更丰富，而且掌纹比指纹更不易受损具有长期稳定性。掌纹识别对图像的分辨率要求不是特别高，所以在采集设备的造价比指纹低很多。 与人脸相比，掌纹不受眼镜、表情、妆容等因素的影响，稳定性较高，并且在用户接受度方面，掌纹的采集方式对用户更加友好。 与虹膜、DNA相比，掌纹的识别准确率虽然不及它们，但是掌纹采集设备造价远低于这两种生物特征识别技术的采集设备。 与签名、步态等行为特征相比，掌纹识别不受人们习惯的影响，特征不会随着时间改变，并且识别的准确率远高于行为特征。 综上所述，掌纹识别有识别精度高、采集设备成本低、稳定性高、用户接受度高等优点，在生活中的应用越来越广泛。 掌纹识别的基本步骤掌纹特征识别过程分为数据库的创建和特征库的检索。 数据库创建通过采集注册样本，进行预处理、特征提取工作，之后形成数据库 特征库检索通过采集待测试的样本，在预处理和提取特征之后与掌纹数据库中的数据进行匹配，得到该待测样本的类别。 掌纹特征提取方法掌纹特征提取方法主要分为四大类，分别为基于结构的方法、基于统计的方法、基于子空间的方法以及基于编码的方法。 基于结构的方法主要是利用掌纹中主线和褶皱的方向和位置信息实现掌纹识别的方法，此类方法最为直观。但是无论是哪一种边缘检测算子都无法提取出所有的纹线，所以此类方法实用性很差，已经被人们渐渐放弃。 基于统计的方法主要是利用统计特征，例如均值、方差等组成一组用来描述掌纹图像的特征向量，可以根据是否分块这一特性分为局部统计变量方法和全局统计量方法。基于局部统计量的方法通过将图像分成若干小块，分别统计每个小块的统计信息，然后将这些统计信息组合表示为整个掌纹的统计特征向量，如采用傅里叶变换、小波变换等方式获得掌纹图像的每个分块统计信息并进行识别。 基于子空间的方法是将原始掌纹图像看做普通的图片模式，将图片对应的高维矩阵通过投影映射运算转化为低维向量或矩阵。根据投影变换的实现方式，分为线性子空间法和非线性子空间法。常用的子空间特征提取方法有主成分分析法(PCA)，FisherPalm方法，BDPCA(Bi-directional PCA)等。 基于编码的方法是将掌纹图像看作纹理图像，根据某些规则对纹理图像进行编码。Zhang等提出了一种名为PalmCode的编码方法，该方法首先采用2DGabor对图像进行滤波处理，然后根据滤波结果的实部和虚部的正负来进行编码。Kong等提出使用六个方向的Gabor滤波器对掌纹图像滤波, 并对幅值最小的方向编码, 称为竞争编码(Competitive code)。由于竞争编码考察了掌纹图像的方向信息，对光照不敏感，因此识别精度很高。 EDCC掌纹充满了线条和纹理特征，具备丰富的方向信息。因此，基于方向编码被认为是最有效的掌纹特征提取方法。而竞争编码是辨识度极高的编码方法之一，它使用不同方向的滤波器与掌纹图像进行卷积，之后根据一定的编码规则对掌纹图像进行编码。 EDCC算法有以下关键点: 通过图像增强算子处理原始掌纹图像，使得纹线更加突出，提取的方向更加准确。 使用一组方向不同的2DGabor小波滤波器对图像进行滤波。 选择滤波响应值最大和次大的方向作为该点所在纹线的主要方向和次要方向，进而进行编码。 下面将对这三个关键点进行详细解释。 图像增强拉普拉斯算子是图像锐化常用的方法，锐化可以增强图像的对比度，突出灰度值变化明显的部分，使比较模糊的纹线变得清晰。 典型的核大小为的拉普拉斯算子: 使用上式中的算子对如下掌纹图像进行卷积 得到增强掌纹后的结果如下图所示。 纹线明显被增强显示出来，而且纹线处的灰度值大大高于周围皮肤灰度值。 实验表明，拉普拉斯增强算子可以有效的增强纹线对比度。所以EDCC算法在对图像使用2DGabor小波滤波之前，先对图像进行拉普拉斯变换。 2DGabor小波2DGabor小波滤波器与人类视觉刺激响应非常相似。如下图所示， 第一行是人类视觉感受野，第二行是Gabor小波滤波器，第三行是两者之间的残差，可见两者及其相似。而且Gabor小波可以变换方向和尺度，对于不同方向的纹线都能很好地适应。 函数形式表示如下： 取3个尺度，6个方向构成一组滤波器，并对掌纹图像进行卷积，得到结果如下图所示 不难发现，经过2DGabor小波滤波后的掌纹纹线非常清晰。 编码采用一组尺度统一方向不同的2DGabor小波滤波器对图像做卷积后，可以得到掌纹图像每一个像素点对应的响应值，不难推断最大响应值对应的滤波器方向可以近似表示该点的掌纹线方向，但并不是纹线准确的方向。 如下图所示，选择掌纹图像主线上的两个像素点与一组方向个数为6的2DGabor小波滤波器进行卷积，并计算相应滤波响应值。然后确定具有最大滤波响应的取向作为主要方向，从图中可以看出，(a)和(b)主要方向是相同的。 实际上，这两个像素的真正的主要方向分别在提取的主要方向的左侧和右侧。这种现象也在掌纹的其他部位也可以发现。因此，基于最大滤波响应提取的主要方向并不能准确地表示掌纹真实的方向。 根据滤波响应提取掌纹主要方向的方法基于掌纹图像中的像素属于一条线的基本假设。当滤波器的方向与掌纹的主要方向相同时，滤波响应将达到最大值。 换句话说，滤波器响应与主线和滤波器之间的重叠程度成正比。然而，因为在实践中使用的滤波器方向有限，可能没有Gabor滤波器具有与掌纹图像的主要方向相同的取向。结果，在这种情况下，提取的方向不能准确地表示掌纹的主要方向特征。 通常来说，2DGabor小波滤波器方向越靠近掌纹的主要方向，得到的滤波响应就越大。因此，提取主要方向（通常也具有较大的滤波响应）的相邻方向可以与主要方向相结合，来更准确地表示掌纹图像。 方法首先使用一个尺度、N个方向的一组2DGabor小波滤波器对图像进行卷积。掌纹纹线上的一点I(x, y)的主要方向通过计算该点最大响应值对应的滤波器方向来确定。即: 式中：C是掌纹图像的主要方向。令Cleft和Cright表示主要方向相邻的方向 通过比较Cleft和Cright方向对应的响应值，得到次要方向Cs的编码 由于C表示掌纹图像的主要方向特征，Cs表示次要方向特征，所以结合C和Cs能够较为准确表示纹线的真实方向。 (C, Cs)的计算例子如下图所示 匹配方式在掌纹图像的匹配阶段，使用与竞争编码方法相似但不同的角距离来确定两个掌纹图像之间的相似度。 两个掌纹图像和之间的匹配得分定义为： 实验验证在掌纹验证这一步中，令掌纹数据库中每个掌纹图像与剩下所有的图像一一对比。假如两幅图像来自同一人，则称之为同类匹配，否则称之为异类匹配。 在多光谱数据库中，每个人有12张手掌图片，每个光谱对应的数据库有6000张图片，所以有个匹配，其中同类匹配有33000个，异类匹配有17964000个。在同济大学掌纹数据库中，同类匹配有114000个，异类匹配有71880000个。图5.7展示了使用EDCC算法在多光谱数据库以及同济大学数据库上得到的匹配得分分布情况。可以发现，同类匹配得分与异类匹配得分明显分离，并且同类匹配得分远高于异类匹配得分。 (a)-(e)分别为Red,Green,Blue,NIR,同济大学数据库 正确接受率(GAR)和错误接受率(FAR)可以评估算法的性能，ROC曲线通过设置所有可能的阈值进而得到对应的GAR和FAR值，并以FAR、GAR的值做为横、纵坐标绘制曲线。 (a)-(e)分别为Red,Green,Blue,NIR,同济大学数据库 上图展示了EDCC算法、DCC算法、小波变换分块统计算法以及BDPCA+LDA算法在不同数据库上验证得到的ROC曲线。忽略产生过拟合的BDPCA+LDA算法，不难发现，当FAR相同时，EDCC算法的GAR最高。 等误率(Equal Error Rate, EER)是FAR=FRR对应的值。去除掉存在过拟合问题的BDPCA+LDA算法，不同算法对应的EER如表下表所示。可以发现，EDCC算法在所有数据库上达到了最低的EER。对比DCC算法，EDCC算法的EER下降率最大达到了73%((5.5105-1.4728)/5.5105)，平均下降率也在50%左右。 EDCC DCC 小波变换分块信息统计 Red 1.2612 4.0145 2.2772 Green 1.8715 4.7460 3.3249 Blue 1.7455 4.5881 3.2456 NIR 1.4728 5.5105 2.0192 同济大学 3.6116 5.3703 6.6747 识别识别是指通过逐个匹配数据库内的掌纹，确定一个未知掌纹来自何人。 在本文的掌纹识别实验中，将每个手掌的N(N=1,2,3,4)张掌纹图像组成训练集，剩下的掌纹图像组成测试集。将测试集中的每张图像与训练集一一比较，来计算匹配得分，训练集中得分最高的样本对应的类别作为该测试图片的类别，通过此方法可以计算不同算法在不同训练集大小下的错误识别率。 (a)-(e)分别为Red,Green,Blue,NIR,同济大学数据库 实验结果如上图所示。可以发现，EDCC算法在训练样本较少时，仍然可以取得较高的识别率，并且在训练样本个数相同的条件下，EDCC算法的错误率明显低于其他算法，换句话说，EDCC算法可以使用更少的训练样本得到更高的识别准确率。]]></content>
      <categories>
        <category>我的开源项目</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git指令整理]]></title>
    <url>%2FGit%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[GitHub创建仓库提示代码echo &quot;# 项目名&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin git@github.com:Leosocy/项目名.git git push -u origin master 若仓库存在直接push git remote add origin git@github.com:Leosocy/test.git git push -u origin master 常用操作创建仓库（初始化）在当前指定目录下创建 git init 新建一个仓库目录 git init [project-name] 克隆一个远程项目 git clone [url] 添加文件到缓存区添加所有变化的文件 git add . 添加名称指定文件 git add text.txt 配置设置提交代码时的用户信息 git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email address]&quot; 提交提交暂存区到仓库区 git commit -m &quot;msg&quot; # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签Tags添加标签 在当前commit git tag -a v1.0 -m &apos;xxx&apos; 添加标签 在指定commit git tag v1.0 [commit] 查看 git tag 删除 git tag -d V1.0 删除远程tag git push origin :refs/tags/[tagName] 推送 git push origin --tags 拉取 git fetch origin tag V1.0 新建一个分支，指向某个tag git checkout -b [branch] [tag] 查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他# 生成一个可供发布的压缩包 $ git archives]]></content>
      <categories>
        <category>基础知识/技能</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown认识与入门]]></title>
    <url>%2FMarkdown%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一、认识MarkdownMarkdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。 Markdown优点。 不用关心排版，让你更注重文字。 语法简单，易读写。 纯文本，兼容所有的文本编辑器。 二、Markdown语法1.标题 用#表示 #可以表示最高6级标题，#的数量对应标题的级数。 一级标题二级标题2.引用在要引用块的句首添加&gt;符号 这是引用 引用是可以嵌套的 这是外层 这是内层 3.列表3.1无序列表无序列表使用*、+或者-作为列表的标记（注意要在这些符号后面加上空格） 一 二 三 3.2 有序列表有序列表使用 数字+.+空格作为列表的标记，而且数字并不决定列表的顺序 一 二 三 ####3.3 无序列表中插入有序列表 菜单一 子菜单1 子菜单2 菜单二 3.3 列表中插入其他元素列表中有引用 列表中的引用 这是列表中的引用 列表中有代码块 列表中的代码块 1printf( "%s", "This is code inside list. " ); 列表中有列表 列表1 列表2 4.代码块用一个反引号`加载一行代码 printf( &quot;%s&quot;, &quot;Use single load one line code. &quot; ) 用三个反引号包含一段代码 12printf( "%s", "Code line one." );printf( "%s", "Code line two." ); 5.链接5.1图片链接使用![图片解释文字](图片地址)加载一幅图片 改变图片的大小并居中 1&lt;img src="url" width="x" height="y" align=center&gt; 5.2网页链接使用[链接文字](网页地址)创建一个网页链接 Github 6.强调斜体*斜体* 我是斜体 粗体**粗体** 我是粗体 粗提+斜体***粗体+斜体*** 我是粗体+斜体` 删除线~~删除我~~ 删除我 7.表格在第二列中，冒号在左面表明左对齐，在右面表明右对齐，两边都有表明居中。默认左居中。 123|姓名|部门||:--:|:--:||张三|无线| 姓名 部门 张三 无线 8.Some Tips结束先前的格式状态在改变格式时，添加一个空行。 9.页内跳转 设置跳转点 [标签](#地址) 设置锚点 &lt;h2 id=&quot;地址&quot;&gt;内容&lt;/h2&gt; e.g. 跳转到示例 跳转到这 跳转点和锚点均支持Markdown的其他语法 跳转到 认识Markdown]]></content>
      <categories>
        <category>基础知识/技能</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>入门</tag>
      </tags>
  </entry>
</search>
